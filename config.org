#+TITLE: Jethro's Emacs.d Configuration
* Introduction
This document is a constant work-in-progress, and will contain the
latest updates to my Emacs configuration. I have gone through several
cycles of Emacs config bankruptcy, and time and time again have come
back to a configuration similar to this.

Notes:
1. I use a Dvorak 60% keyboard, so some of the keybindings may not
   apply for you.
2. I use Stumpwm, so some of my configurations are created around that
   as well.

* Core Setup
** Add [[https://github.com/jwiegley/use-package/issues/70][use-package]]
Use-package allows for isolation of package configuration, while
maintaining tidiness and performance.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-and-compile
  (defvar use-package-verbose t) 
  (require 'cl)
  (require 'use-package)
  (require 'bind-key)
  (require 'diminish)
  (setq use-package-always-ensure t))
#+END_SRC
** Emacs Server
Load the emacs server, if it is not running. This allows for
almost-instant emacs "startup".

 #+BEGIN_SRC emacs-lisp :tangle no
   (load "server")
   (unless (server-running-p) (server-start))
 #+END_SRC
** Reloading the init file
I want an easy way to reload my configuration when I change it. I bind
it to =<f11>=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun reload-init ()
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (global-set-key (kbd "<f11>") 'reload-init)
#+END_SRC

** Tweaking Emacs settings
Reduce the frequency of garbage collection by making it happen on each
50MB of allocated data (the default is on every 0.76MB). Also, warn
when opening large files.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gc-cons-threshold 50000000)
  (setq large-file-warning-threshold 100000000)
#+END_SRC
** User configuration
   #+begin_src emacs-lisp :tangle yes
(setq user-full-name "Jethro Kuan"
      user-mail-address "jethrokuan95@gmail.com")
   #+end_src
** =jethro-mode-map=
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar jethro-mode-map (make-sparse-keymap)
    "Keymap for `jethro-mode'.")

  (define-minor-mode jethro-mode
    "A minor mode so that my key settings override annoying major modes."
    ;; If init-value is not set to t, this mode does not get enabled in
    ;; `fundamental-mode' buffers even after doing \"(global-jethro-mode 1)\".
    ;; More info: http://emacs.stackexchange.com/q/16693/115
    :init-value t
    :lighter    " j"
    :keymap     jethro-mode-map)

  (define-globalized-minor-mode global-jethro-mode jethro-mode jethro-mode)

  ;; https://github.com/jwiegley/use-package/blob/master/bind-key.el
  ;; The keymaps in `emulation-mode-map-alists' take precedence over
  ;; `minor-mode-map-alist'
  (add-to-list 'emulation-mode-map-alists `((jethro-mode . ,jethro-mode-map)))

  ;; Turn off the minor mode in the minibuffer
  (defun turn-off-jethro-mode ()
    "Turn off jethro-mode."
    (jethro-mode -1))
  (add-hook 'minibuffer-setup-hook #'turn-off-jethro-mode)

#+END_SRC
** Auto Revert
Many times when switching git branches, files tend to change. By
default, Emacs does not revert the buffers affected, which can lead to
some confusion. Turn on =auto-revert-mode= globally, so that when the
files change, the buffers reflect the latest editions as well.

NOTE: This can be quite slow, when the changes are massive across branches.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
#+END_SRC

** Custom file
Using the customize interface can be nice, but it tends to pollute
=init.el=. Move all customizations to a separate file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'initial-frame-alist
               '(font . "Iosevka-12"))
  (add-to-list 'default-frame-alist
               '(font . "Iosevka-12"))
#+END_SRC

** UI Cruft
Remove useless toolbars and splash screens.

#+begin_src emacs-lisp :tangle yes
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+end_src

** Use y/n over yes/no
Always prefer the shorter y/n over yes/no.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Replace region when typing
Type over a selected region, instead of deleting before typing.

#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode 1)
#+end_src

** Recentf
When I'm using Emacs via =emacsclient=, my recent files don't get
saved because I never ever quit Emacs. Instead, now I run the function
every 5 minutes.

#+BEGIN_SRC emacs-lisp :tangle yes
  (run-at-time (current-time) 300 'recentf-save-list)
#+END_SRC

** Sentences
Emacs uses double-spaces by default. Use single spaces instead:

#+begin_src emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+end_src

** Tab with 2 spaces
#+begin_src emacs-lisp :tangle yes
  (setq-default tab-width 2)
  (setq-default js-indent-level 2)
  (setq-default indent-tabs-mode nil)
#+end_src

** Don't wrap lines
Don't wrap lines for coding. Create a hook that enables wrapping, for
text-modes like org-mode and markdown-mode.

#+begin_src emacs-lisp :tangle yes
  (setq-default truncate-lines t)

  (defun truncate-lines-hook ()
    (setq truncate-lines nil))

  (add-hook 'text-mode-hook 'truncate-lines-hook)
#+end_src

** Backup directory
#+begin_src emacs-lisp :tangle yes
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+end_src

#+begin_src emacs-lisp :tangle no
(message "Deleting old backup files...")
(let ((week (* 60 60 24 7))
      (current (float-time (current-time))))
  (dolist (file (directory-files temporary-file-directory t))
    (when (and (backup-file-name-p file)
               (> (- current (float-time (fifth (file-attributes file))))
                  week))
      (message "%s" file)
      (delete-file file))))
#+end_src
** Load secrets
Store secrets in a different file, not committed into the git
repository.

#+begin_src emacs-lisp :tangle yes
(load "~/.emacs.d/secrets.el" t)
#+end_src
** Shell
*** Default shell
#+begin_src emacs-lisp :tangle yes
  (setq-default explicit-shell-file-name "/bin/bash")
  (setq-default shell-file-name "/bin/bash")
#+end_src
*** Add PATH to eshell
#+begin_src emacs-lisp :tangle yes
   (use-package exec-path-from-shell 
     :config
     (exec-path-from-shell-initialize))
#+end_src
** Theme (Zenburn)
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package zenburn-theme
      :init
      (load-theme 'zenburn t))
#+END_SRC
** Keybindings
*** Nuke all buffers with =C-c !=
#+begin_src emacs-lisp :tangle yes
  (defun jethro/nuke-all-buffers ()
    (interactive)
    (mapcar 'kill-buffer (buffer-list))
    (delete-other-windows))

  (bind-key "C-c !" 'jethro/nuke-all-buffers jethro-mode-map)
#+end_src
*** eshell with =C-x m=
#+begin_src emacs-lisp :tangle yes
  (bind-key "C-x m" 'eshell jethro-mode-map)
#+end_src
*** compile with =<f9>=
#+begin_src emacs-lisp :tangle yes
  (defun jethro/compile () 
    (interactive)
    (setq-local compilation-read-command nil)
    (call-interactively 'compile))

  (bind-key "<f9>" 'jethro/compile jethro-mode-map)
#+end_src
** Hydra
#+begin_src emacs-lisp :tangle yes
  (use-package hydra)
#+end_src
** Ivy
I've recently switched over from =helm= to =ivy=. Ivy is simpler, and
easier to extend.
*** flx
Flx is required for fuzzy-matching.
#+begin_src emacs-lisp :tangle yes
  (use-package flx)
#+end_src
*** Fuzzy Isearch
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flx-isearch
    :bind (:map jethro-mode-map
                ("C-M-s" . flx-isearch-forward)
                ("C-M-r" . flx-isearch-backward)))
#+END_SRC
*** Counsel
Counsel contains ivy enhancements for commonly-used functions.
#+begin_src emacs-lisp :tangle yes
  (use-package counsel
    :diminish ivy-mode
    :bind
    (:map jethro-mode-map
          ("C-c C-r" . ivy-resume)
          ("M-a" . counsel-M-x)
          ("C-c i" . counsel-imenu)
          ("C-x C-f" . counsel-find-file)
          ("C-x j" . counsel-dired-jump)
          ("C-x l" . counsel-locate)
          ("C-c j" . counsel-git)
          ("C-c s" . counsel-projectile-rg)
          ("C-c f" . counsel-recentf)
          ("M-y" . counsel-yank-pop))
    :bind ((:map help-map
                 ("f" . counsel-describe-function)
                 ("v" . counsel-describe-variable)
                 ("l" . counsel-info-lookup-symbol))
           (:map ivy-minibuffer-map
                 ("C-d" . ivy-dired)
                 ("C-o" . ivy-occur))
           (:map read-expression-map
                 ("C-r" . counsel-expression-history))
           (:map ivy-minibuffer-map
                 ("<return>" . ivy-alt-done)
                 ("M-<return>" . ivy-immediate-done)))
    :init
    (add-hook 'after-init-hook (lambda () (ivy-mode 1)))
    :config
    (defun ivy-dired ()
      (interactive)
      (if ivy--directory
          (ivy-quit-and-run
           (dired ivy--directory)
           (when (re-search-forward
                  (regexp-quote
                   (substring ivy--current 0 -1)) nil t)
             (goto-char (match-beginning 0))))
        (user-error
         "Not completing files currently"))) 
    (setq counsel-find-file-at-point t)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((ivy-switch-buffer . ivy--regex-plus)
            (swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))) 
    (ivy-set-actions
     t
     '(("I" insert "insert"))))
   #+end_src
* Visual Enhancements
** Whitespace-mode
#+begin_src emacs-lisp :tangle yes
  (require 'whitespace)
  (setq whitespace-line-column 80) ;; limit line length
  (setq whitespace-style '(face lines-tail))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+end_src
** Page-break-lines
#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines)
#+end_src
** Smart-mode-line
#+begin_src emacs-lisp :tangle yes
  (use-package smart-mode-line
    :init
    (add-hook 'after-init-hook 'sml/setup)
    :config 
    (setq sml/theme 'respectful)
    (setq sml/name-width 30)
    (setq sml/shorten-directory t)
    (setq sml/shorten-modes t)
    (setq sml/mode-width 'full)
    (setq sml/replacer-regexp-list
                   '(("^~/.org/" ":O:")
                     ("^~/\\.emacs\\.d/" ":ED")))
    (setq rm-blacklist
                   (format "^ \\(%s\\)$"
                           (mapconcat #'identity
                                      '("FlyC.*"
                                        "Projectile.*"
                                        "GitGutter"
                                        "ivy"
                                        "company"
                                        ""
                                        "doom"
                                        ","
                                        "ElDoc")
                                      "\\|"))))
#+end_src
*** Showing time
#+begin_src emacs-lisp :tangle yes
  (display-time-mode 1)
  (eval-after-load "display-time-mode"
    (setq display-time-24hr-format t))
#+end_src
** Zooming
   #+begin_src emacs-lisp :tangle yes
     (defhydra jethro/hydra-zoom ()
       "zoom"
       ("i" text-scale-increase "in")
       ("o" text-scale-decrease "out"))

     (bind-key "C-c h z" 'jethro/hydra-zoom/body jethro-mode-map)
   #+end_src
** beacon
Beacon makes sure you don't lose track of your cursor when jumping around a buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package beacon
    :diminish beacon-mode
    :init
    (add-hook 'after-init-hook 'beacon-mode)
    :config 
    (setq beacon-push-mark 10))
#+end_src
** Show Matching parenthesis
Always show matching parenthesis.
#+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)
(setq show-paren-delay 0)
#+end_src
** golden-ratio
Give the working window more screen estate.

#+begin_src emacs-lisp :tangle yes
  (use-package golden-ratio
    :diminish golden-ratio-mode
    :init
    (add-hook 'after-init-hook 'golden-ratio-mode))
#+end_src
** volatile-highlights
Highlights recently copied/pasted text.
#+begin_src emacs-lisp :tangle yes
     (use-package volatile-highlights
       :diminish volatile-highlights-mode
       :init
       (add-hook 'after-init-hook 'volatile-highlights-mode))
#+end_src
** add-log
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package add-log
    :commands (jethro/add-change-log-entry-other-window-and-return)
    :config
    (progn
      (defun jethro/add-change-log-entry-other-window-and-return ()
        "Call `add-change-log-entry-other-window' and return to the previous window."
        (interactive)
        (add-change-log-entry-other-window)
        (select-window (previous-window)))))
#+END_SRC
** diff-hl
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package diff-hl
    :bind (:map jethro-mode-map 
                ("C-c h v" . jethro/hydra-diff-hl/body))
    :init 
    (defconst jethro/diff-hl-mode-hooks '(emacs-lisp-mode-hook
                                          conf-space-mode-hook ;.tmux.conf
                                          markdown-mode-hook
                                          css-mode-hook
                                          web-mode-hook
                                          sh-mode-hook
                                          python-mode-hook
                                          yaml-mode-hook ;tmuxp yaml configs
                                          c-mode-hook)
      "List of hooks of major modes in which diff-hl-mode should be enabled.")

    (dolist (hook jethro/diff-hl-mode-hooks)
      (add-hook hook #'diff-hl-mode))

    (defhydra jethro/hydra-diff-hl (:color red)
      "diff-hl"
      ("=" diff-hl-diff-goto-hunk "goto hunk")
      ("<RET>" diff-hl-diff-goto-hunk "goto hunk")
      ("u" diff-hl-revert-hunk "revert hunk")
      ("[" diff-hl-previous-hunk "prev hunk")
      ("p" diff-hl-previous-hunk "prev hunk")
      ("]" diff-hl-next-hunk "next hunk")
      ("n" diff-hl-next-hunk "next hunk")
      ("a" jethro/add-change-log-entry-other-window-and-return "add change log entry")
      ("q" nil "cancel"))

    (add-hook 'dired-mode-hook #'diff-hl-dired-mode))
#+END_SRC
* Moving Around
** guru-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package guru-mode
    :diminish guru-mode
    :init
    (add-hook 'after-init-hook 'guru-global-mode))
#+END_SRC
** keychord
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (use-package key-chord
    :diminish key-chord-mode
    :config
    (key-chord-mode 1)
    (key-chord-define-global ";q" 'avy-goto-char-timer)
    (key-chord-define-global "jk" 'other-window)
    (key-chord-define-global "qj" 'switch-to-previous-buffer)
    (key-chord-define-global "zv" 'ibuffer))
#+END_SRC
** Crux
#+begin_src emacs-lisp :tangle yes
  (use-package crux 
    :bind (:map jethro-mode-map
                ("C-c o" . crux-open-with)
                ("C-c n" . crux-cleanup-buffer-or-region)
                ("C-c D" . crux-delete-file-and-buffer)
                ("C-a" . crux-move-beginning-of-line)
                ("M-o" . crux-smart-open-line)
                ("C-c r" . crux-rename-file-and-buffer)
                ("M-d" . crux-duplicate-current-line-or-region)
                ("M-D" . crux-duplicate-and-comment-current-line-or-region)
                ("s-o" . crux-smart-open-line-above)))

#+end_src
** Anzu
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package anzu
    :diminish anzu-mode
    :init
    (add-hook 'after-init-hook 'global-anzu-mode)
    :config
    (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
    (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp))
#+END_SRC
** avy
Use avy to move between visible text.
#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :bind
    (:map jethro-mode-map
          ("C-'" . avy-goto-char)
          ("C-," . avy-goto-char-2))
    :config
    (setq avy-keys '(?h ?t ?n ?s)))
#+end_src
** dumb-jump
Use it to jump to function definitions. Requires no external depedencies.
#+begin_src emacs-lisp :tangle no
  (use-package dumb-jump
    :diminish dumb-jump-mode
    :bind (:map jethro-mode-map
                ("C-M-g" . dumb-jump-go)
                ("C-M-p" . dumb-jump-back)
                ("C-M-q" . dumb-jump-quick-look)))
#+end_src
** Window switching
#+begin_src emacs-lisp :tangle yes
  (use-package windmove 
    :config
    ;; use command key on Mac
    (windmove-default-keybindings 'super)
    ;; wrap around at edges
    (setq windmove-wrap-around t))
#+end_src
** ace-window (disabled)
   Ace-window makes it easier to move between windows.
   #+begin_src emacs-lisp :tangle no
  (use-package ace-window
    :bind ("M-'" . ace-window)
    :config
    (setq aw-keys '(?h ?t ?n ?s)))
   #+end_src
** dired
*** Requiring =dired=
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired)
#+END_SRC
*** Dired for Mac OSX
#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((gls "/usr/local/bin/gls"))
    (if (file-exists-p gls) (setq insert-directory-program gls)))
#+END_SRC
*** trash files instead of deleting them
    #+BEGIN_SRC emacs-lisp :tangle yes
  (setq delete-by-moving-to-trash t)
    #+END_SRC
*** find-dired
    #+BEGIN_SRC emacs-lisp :tangle yes
  (require 'find-dired)
  (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    #+END_SRC
*** Hide details
    Hide details and only show file and folder names.
    #+begin_src emacs-lisp :tangle no
  (defun jethro/dired-mode-setup-hook ()
    "hook for dired-mode"
    (dired-hide-details-mode 1))

  (add-hook 'dired-mode-hook 'jethro/dired-mode-setup-hook)
    #+end_src
*** Sort directories first
    #+begin_src emacs-lisp :tangle yes
(setq dired-listing-switches "-aBhl  --group-directories-first")
    #+end_src
*** Recursive Copying and Deleting
    #+begin_src emacs-lisp :tangle yes
  (setq dired-recursive-copies (quote always))
  (setq dired-recursive-deletes (quote top))
    #+end_src
*** dired-jump from file
    #+begin_src emacs-lisp :tangle yes
  (require 'dired-x)
    #+end_src
*** allow editing of permissions
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package wdired
        :config
        (setq wdired-allow-to-change-permissions t))
    #+END_SRC
*** dired-k
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-k
    :config
    (define-key dired-mode-map (kbd "K") 'dired-k)
    (setq dired-k-style 'git))
    #+END_SRC
*** dired-narrow
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("N" . dired-narrow-fuzzy)))
    #+END_SRC
*** dired-ranger
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-ranger
    :bind (:map dired-mode-map
                ("C" . dired-ranger-copy)
                ("P" . dired-ranger-paste)
                ("M" . dired-ranger-move)))
    #+END_SRC
** hydra window movements
#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra jethro/window-movement ()
    ("h" windmove-left)
    ("s" windmove-right)
    ("t" windmove-down)
    ("n" windmove-up)
    ("y" other-window "other") 
    ("f" find-file "file")
    ("F" find-file-other-window "other file")
    ("v" (progn (split-window-right) (windmove-right)))
    ("o" delete-other-windows :color blue)
    ("d" delete-window "delete")
    ("q" nil))

  (key-chord-define-global "-s" 'jethro/window-movement/body)
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :bind (:map jethro-mode-map
                ([remap list-buffers] . ibuffer))
    :config 
    (setq ibuffer-default-sorting-mode 'major-mode)
    (setq ibuffer-expert t)
    (use-package ibuffer-projectile
      :config
      (progn
        (defun jethro/ibuffer-customization ()
          "My customization for `ibuffer'."
          ;; ibuffer-projectile setup
          (ibuffer-projectile-set-filter-groups)
          (unless (eq ibuffer-sorting-mode 'alphabetic)
            (ibuffer-do-sort-by-alphabetic) ; first do alphabetic sort
            (ibuffer-do-sort-by-major-mode))))) ; then do major-mode sort

    ;; ibuffer-projectile setup
    (add-hook 'ibuffer-hook #'jethro/ibuffer-customization))
#+END_SRC
** shackle
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package shackle
    :diminish shackle-mode
    :if (not (bound-and-true-p disable-pkg-shackle))
    :config
    (shackle-mode 1) 
    (setq shackle-rules 
          '((compilation-mode :select nil)
            ("*undo-tree*" :size 0.25 :align right)
            ("*eshell*" :select t :size 0.3 :align t)
            ("*Shell Command Output*" :select nil)
            ("\\*Async Shell.*\\*" :regexp t :ignore t)
            (occur-mode :select nil :align t)
            ("*Help*" :select t :inhibit-window-quit t :other t)
            ("*Completions*" :size 0.3 :align t)
            ("*Messages*" :select nil :inhibit-window-quit t :other t)
            ("\\*[Wo]*Man.*\\*" :regexp t :select t :inhibit-window-quit t :other t) 
            ("*Calendar*" :select t :size 0.3 :align below)
            ("*info*" :select t :inhibit-window-quit t :same t)
            (magit-status-mode :select t :inhibit-window-quit t :same t)
            (magit-log-mode :select t :inhibit-window-quit t :same t))))
#+END_SRC
** go to matching parentheses
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun goto-match-paren (arg)
    "Go to the matching parenthesis if on parenthesis, otherwise insert %.
  vi style of % jumping to matching brace."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))

  (bind-key "C-%" 'goto-match-paren jethro-mode-map)
#+END_SRC
* Editing Text
** easy-kill
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill))
#+END_SRC
** visual-regexp
#+begin_src emacs-lisp :tangle yes
  (use-package visual-regexp
    :bind (:map jethro-mode-map
                ("C-M-%" . vr/query-replace)
                ("C-c m" . vr/mc-mark)))
#+end_src
** Align Regexp
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun jethro/align-repeat (start end regexp &optional justify-right after)
    "Repeat alignment with respect to the given regular expression.
  If JUSTIFY-RIGHT is non nil justify to the right instead of the
  left. If AFTER is non-nil, add whitespace to the left instead of
  the right."
    (interactive "r\nsAlign regexp: ")
    (let* ((ws-regexp (if (string-empty-p regexp)
                          "\\(\\s-+\\)"
                        "\\(\\s-*\\)"))
           (complete-regexp (if after
                                (concat regexp ws-regexp)
                              (concat ws-regexp regexp)))
           (group (if justify-right -1 1)))
      (message "%S" complete-regexp)
      (align-regexp start end complete-regexp group 1 t)))

  ;; Modified answer from http://emacs.stackexchange.com/questions/47/align-vertical-columns-of-numbers-on-the-decimal-point
  (defun jethro/align-repeat-decimal (start end)
    "Align a table of numbers on decimal points and dollar signs (both optional)"
    (interactive "r")
    (require 'align)
    (align-region start end nil
                  '((nil (regexp . "\\([\t ]*\\)\\$?\\([\t ]+[0-9]+\\)\\.?")
                         (repeat . t)
                         (group 1 2)
                         (spacing 1 1)
                         (justify nil t)))
                  nil))

  (defmacro jethro/create-align-repeat-x (name regexp &optional justify-right default-after)
    (let ((new-func (intern (concat "jethro/align-repeat-" name))))
      `(defun ,new-func (start end switch)
         (interactive "r\nP")
         (let ((after (not (eq (if switch t nil) (if ,default-after t nil)))))
           (jethro/align-repeat start end ,regexp ,justify-right after)))))

  (jethro/create-align-repeat-x "comma" "," nil t)
  (jethro/create-align-repeat-x "semicolon" ";" nil t)
  (jethro/create-align-repeat-x "colon" ":" nil t)
  (jethro/create-align-repeat-x "equal" "=")
  (jethro/create-align-repeat-x "math-oper" "[+\\-*/]")
  (jethro/create-align-repeat-x "ampersand" "&")
  (jethro/create-align-repeat-x "bar" "|")
  (jethro/create-align-repeat-x "left-paren" "(")
  (jethro/create-align-repeat-x "right-paren" ")" t)
  (jethro/create-align-repeat-x "backslash" "\\\\")

  (defvar align-regexp-map nil "keymap for `align-regexp'")

  (setq align-regexp-map (make-sparse-keymap))
  (define-key align-regexp-map (kbd "&") 'jethro/align-repeat-ampersand)
  (define-key align-regexp-map (kbd "(") 'jethro/align-repeat-left-paren)
  (define-key align-regexp-map (kbd ")") 'jethro/align-repeat-right-paren)
  (define-key align-regexp-map (kbd ",") 'jethro/align-repeat-comma)
  (define-key align-regexp-map (kbd ".") 'jethro/align-repeat-decimal)
  (define-key align-regexp-map (kbd ":") 'jethro/align-repeat-colon)
  (define-key align-regexp-map (kbd ";") 'jethro/align-repeat-semicolon)
  (define-key align-regexp-map (kbd "=") 'jethro/align-repeat-equal)
  (define-key align-regexp-map (kbd "\\") 'jethro/align-repeat-backslash)
  (define-key align-regexp-map (kbd "a") 'align)
  (define-key align-regexp-map (kbd "c") 'align-current)
  (define-key align-regexp-map (kbd "m") 'jethro/align-repeat-math-oper)
  (define-key align-regexp-map (kbd "r") 'jethro/align-repeat)
  (define-key align-regexp-map (kbd "|") 'jethro/align-repeat-bar)

  (bind-key "C-x a" 'align-regexp-map jethro-mode-map)
#+END_SRC
** Fancy Narrow
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fancy-narrow
    :init
    (add-hook 'after-init-hook 'fancy-narrow-mode))
#+END_SRC
** aggressive-indent
   Keep your text indented at all times. Remember to turn this off for indentation-dependent languages like Python and Haml.
   #+begin_src emacs-lisp :tangle yes
(use-package aggressive-indent
  :diminish aggressive-indent-mode
  :config (add-hook 'prog-mode-hook 'aggressive-indent-mode))
   #+end_src
** multiple-cursors
   A port of Sublime Text's multiple-cursors functionality.
   #+begin_src emacs-lisp :tangle yes
     (use-package multiple-cursors
       :bind (:map jethro-mode-map
                   ("C-M-c" . mc/edit-lines)
                   ("C->" . mc/mark-next-like-this)
                   ("C-<" . mc/mark-previous-like-this)
                   ("C-c C-<" . mc/mark-all-like-this)))
   #+end_src
** expand-region
   Use this often, and in combination with multiple-cursors.
   #+begin_src emacs-lisp :tangle yes
     (use-package expand-region
       :bind (:map jethro-mode-map
                   ("C-=" . er/expand-region)))
   #+end_src
** iedit
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package iedit)
   #+END_SRC
** smartparens
   #+begin_src emacs-lisp :tangle yes
     (use-package smartparens
       :bind
       (:map smartparens-mode-map
             ("C-M-f" . sp-forward-sexp)
             ("C-M-b" . sp-backward-sexp)
             ("C-M-u" . sp-backward-up-sexp)
             ("C-M-d" . sp-down-sexp)
             ("C-M-p" . sp-backward-down-sexp)
             ("C-M-n" . sp-up-sexp)
             ("M-s" . sp-splice-sexp)
             ("M-<up>" . sp-splice-sexp-killing-backward)
             ("M-<down>" . sp-splice-sexp-killing-forward)
             ("M-r" . sp-splice-sexp-killing-around)
             ("C-)" . sp-forward-slurp-sexp)
             ("C-<right>" . sp-forward-slurp-sexp)
             ("C-}" . sp-forward-barf-sexp)
             ("C-<left>" . sp-forward-barf-sexp)
             ("C-(" . sp-backward-slurp-sexp)
             ("C-M-<left>" . sp-backward-slurp-sexp)
             ("C-{" . sp-backward-barf-sexp)
             ("C-M-<right>" . sp-backward-barf-sexp)
             ("M-S" . sp-split-sexp))
       :init
       (add-hook 'lisp-mode-hook 'turn-on-smartparens-strict-mode)
       (add-hook 'emacs-lisp-mode-hook 'turn-on-smartparens-strict-mode)
       (add-hook 'clojure-mode-hook 'turn-on-smartparens-strict-mode)
       (add-hook 'js2-mode-hook 'turn-on-smartparens-strict-mode)
       :config
       (require 'smartparens-config)

       ;; Org-mode config

       (sp-with-modes 'org-mode
         (sp-local-pair "'" nil :unless '(sp-point-after-word-p))
         (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
         (sp-local-pair "_" "_" :unless '(sp-point-after-word-p))
         (sp-local-pair "/" "/" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
         (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
         (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
         (sp-local-pair "«" "»"))

       (defun sp--org-skip-asterisk (ms mb me)
         (or (and (= (line-beginning-position) mb)
                  (eq 32 (char-after (1+ mb))))
             (and (= (1+ (line-beginning-position)) me)
                  (eq 32 (char-after me))))))
   #+end_src
** zap-up-to-char
   #+begin_src emacs-lisp :tangle yes
     (autoload 'zap-up-to-char "misc"
       "Kill up to, but not including ARGth occurrence of CHAR.

       \(fn arg char)"
       'interactive)

     (bind-key "M-z" 'zap-up-to-char jethro-mode-map)
   #+end_src
** move-text
   #+begin_src emacs-lisp :tangle yes
     (use-package move-text
       :bind (:map jethro-mode-map
                   ("M-<up>" . move-text-up)
                   ("M-<down>" . move-text-down)))
   #+end_src
** Linting with Flycheck
   #+begin_src emacs-lisp :tangle yes
     (use-package flycheck
       :bind (:map jethro-mode-map
                   ("C-c h f" . jethro/hydra-flycheck/body))
       :init
       (add-hook 'prog-mode-hook 'global-flycheck-mode)
       :config
       (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers
                             '(javascript-jshint)))
       (defhydra jethro/hydra-flycheck
         (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
               :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
               :hint nil)
         "Errors"
         ("f"  flycheck-error-list-set-filter                            "Filter")
         ("n"  flycheck-next-error                                       "Next")
         ("p"  flycheck-previous-error                                   "Previous")
         ("<" flycheck-first-error                                      "First")
         (">"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
         ("q"  nil))
       (use-package flycheck-pos-tip
         :init
         (add-hook 'flycheck-mode-hook 'flycheck-pos-tip-mode))
       (use-package flycheck-color-mode-line
         :init
         (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
   #+end_src
** Templating with Yasnippet
   #+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish yas-global-mode yas-minor-mode
    :init (add-hook 'after-init-hook 'yas-global-mode)
    :config (setq yas-snippet-dirs '("~/.emacs.d/snippets/")))
   #+end_src
** Autocompletions with Company
   #+begin_src emacs-lisp :tangle yes
     (use-package company
       :diminish company-mode
       :bind (:map company-active-map
                   ("M-n" . nil)
                   ("M-p" . nil)
                   ("C-n" . company-select-next)
                   ("C-p" . company-select-previous))
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (require 'company-dabbrev)
       (require 'company-dabbrev-code)
       (setq company-dabbrev-ignore-case nil
             company-dabbrev-code-ignore-case nil
             company-dabbrev-downcase nil
             company-idle-delay 0
             company-begin-commands '(self-insert-command)
             company-transformers '(company-sort-by-occurrence))
       (use-package company-quickhelp
         :config (company-quickhelp-mode 1)))
   #+end_src
** Spellcheck with Flyspell
   #+begin_src emacs-lisp :tangle yes
     (use-package flyspell 
       :ensure f 
       :diminish flyspell-mode
       :init
       (setenv "DICTIONARY" "en_GB")
       :config   
       (add-hook 'text-mode-hook 'flyspell-mode))
   #+end_src
** Auto-fill-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC
** Conveniences
*** Fill and unfill paragraphs
Stolen from http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun endless/fill-or-unfill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
           (if (eq last-command 'endless/fill-or-unfill)
               (progn (setq this-command nil)
                      (point-max))
             fill-column)))
      (call-interactively #'fill-paragraph)))

  (global-set-key [remap fill-paragraph]
                  #'endless/fill-or-unfill)
#+END_SRC
* Environment
** Direnv
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package direnv
    :config
    (direnv-mode)
    (setq direnv-always-show-summary t))
#+END_SRC
* Languages
** Common Lisp
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package slime
    :config
    (setq inferior-lisp-program "sbcl")
    (setq slime-contribs '(slime-fancy))
    (use-package slime-company
      :config
      (slime-setup '(slime-company))))
#+END_SRC
** Emacs Lisp
#+begin_src emacs-lisp :tangle yes
  (bind-key "C-c C-k" 'eval-buffer emacs-lisp-mode-map)
#+end_src
** Nix
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nix-mode
    :config
    (add-hook 'nix-mode-hook (lambda ()
                               (aggressive-indent-mode -1)))
    (use-package company-nixos-options
      :config
      (add-to-list 'company-backends 'company-nixos-options)))
#+END_SRC
** Go
   #+begin_src emacs-lisp :tangle yes
     (use-package go-mode
       :mode ("\\.go\\'" . go-mode)
       :config
       (add-hook 'go-mode-hook 'compilation-auto-quit-window)
       (add-hook 'go-mode-hook (lambda ()
                                 (set (make-local-variable 'company-backends) '(company-go))
                                 (company-mode)))
       (add-hook 'go-mode-hook (lambda ()
                                 (add-hook 'before-save-hook 'gofmt-before-save)
                                 (local-set-key (kbd "M-.") 'godef-jump)))
       (add-hook 'go-mode-hook
                 (lambda ()
                   (unless (file-exists-p "Makefile")
                     (set (make-local-variable 'compile-command)
                          (let ((file (file-name-nondirectory buffer-file-name)))
                            (format "go build %s"
                                    file))))))
       (use-package go-dlv
         :config (require 'go-dlv))
       (use-package golint
         :config
         (add-to-list 'load-path (concat (getenv "GOPATH")  "/src/github.com/golang/lint/misc/emacs"))
         (require 'golint))
       (use-package gorepl-mode
         :config (add-hook 'go-mode-hook #'gorepl-mode))
       (use-package company-go
         :config (add-hook 'go-mode-hook (lambda ()
                                           (set (make-local-variable 'company-backends) '(company-go))
                                           (company-mode)))))
   #+end_src
** C
#+BEGIN_SRC emacs-lisp :tangle no
  (defun jethro/compile-c () 
    (unless (file-exists-p "Makefile")
      (set (make-local-variable 'compile-command)
           (let ((file (file-name-nondirectory buffer-file-name)))
             (format "cc -Wall %s -o %s --std=c99"
                     file
                     (file-name-sans-extension file))))))

  (add-hook 'c-mode-hook jethro/compile-c)
#+END_SRC
** C++
*** C++ compile function
    #+begin_src emacs-lisp :tangle yes
(add-hook 'c++-mode-hook
          (lambda ()
            (unless (file-exists-p "Makefile")
              (set (make-local-variable 'compile-command)
                   (let ((file (file-name-nondirectory buffer-file-name)))
                     (format "g++ -Wall -s -pedantic-errors %s -o %s --std=c++14"
                             file
                             (file-name-sans-extension file)))))))
    #+end_src
** Fish
   #+begin_src emacs-lisp :tangle yes
  (use-package fish-mode
    :mode ("\\.fish\\'" . fish-mode)
    :init (add-hook 'fish-mode-hook
                    (lambda () (aggressive-indent-mode -1))))
   #+end_src
** Rust
   #+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
   #+end_src
** Python
*** Disabling aggressive-indent-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'python-mode-hook (lambda () (aggressive-indent-mode -1)))
#+END_SRC
*** Python Path
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-after-load "python-mode"
    (lambda ()
      (setq python-remove-cwd-from-path t)))
#+END_SRC
*** Sphinx Docs
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sphinx-doc
    :init
    (add-hook 'python-mode-hook (lambda ()
                                  (sphinx-doc-mode 1))))
#+END_SRC
*** Anaconda
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package anaconda-mode
    :init
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC
**** Company
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-anaconda
    :config
    (eval-after-load "company"
      '(add-to-list 'company-backends '(company-anaconda))))
#+END_SRC
*** isort
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package py-isort
    :commands
    (py-isort-buffer py-isort-region))
#+END_SRC
*** yapfify
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yapfify)
#+END_SRC
*** pytest
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pytest
    :bind (:map python-mode-map
                ("C-c a" . pytest-all)
                ("C-c m" . pytest-module)
                ("C-c ." . pytest-one)
                ("C-c d" . pytest-directory)
                ("C-c p a" . pytest-pdb-all)
                ("C-c p m" . pytest-pdb-module)
                ("C-c p ." . pytest-pdb-one)))
#+END_SRC
*** realgud
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package realgud)
#+END_SRC
*** Highlight Indent Guides
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package highlight-indent-guides
    :init
    (add-hook 'python-mode-hook 'highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'character))
#+END_SRC
** HTML
*** Web-mode
    #+begin_src emacs-lisp :tangle yes
   (use-package web-mode
     :mode (("\\.html\\'" . web-mode)
            ("\\.html\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.jinja\\'" . web-mode)
            ("\\.njk\\'" . web-mode)
            ("\\.php\\'" . web-mode))
     :config
     (setq web-mode-enable-css-colorization t)
     (setq web-mode-code-indent-offset 2)
     (setq web-mode-markup-indent-offset 2))
    #+end_src
*** Emmet-mode
    #+begin_src emacs-lisp :tangle yes
(use-package emmet-mode
  :diminish emmet-mode
  :config
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'vue-mode-hook 'emmet-mode))
    #+end_src
** CSS
*** Rainbow-mode
    #+begin_src emacs-lisp :tangle no
   (use-package rainbow-mode
     :diminish rainbow-mode
     :config
     (add-hook 'css-mode-hook 'rainbow-mode)
     (add-hook 'scss-mode-hook 'rainbow-mode))
    #+end_src
*** SCSS-mode
    #+begin_src emacs-lisp :tangle yes
 (use-package scss-mode
   :mode "\\.scss\\'" 
   :config (progn
             (setq scss-compile-at-save nil)))
    #+end_src
** JS
*** JS2-mode
Here I also added =tern-mode=. This requires the tern executable:
#+begin_src bash :tangle no
npm install -g tern
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package js2-mode
    :mode ("\\.js\\'" . js2-mode)
    :config
    (use-package tern
      :diminish tern-mode
      :config
      (setq js-switch-indent-offset 2)
      (add-hook 'js2-mode-hook 'tern-mode) 
      (use-package company-tern
        :config
        (add-to-list 'company-backends 'company-tern))))
#+end_src
*** Indium
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package indium)
#+END_SRC
*** Flycheck
#+begin_src emacs-lisp :tangle yes
  (require 'flycheck)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (flycheck-add-mode 'javascript-eslint 'web-mode)
#+end_src
*** Skewer
    #+begin_src emacs-lisp :tangle yes
  (use-package skewer-mode  
    :bind (:map skewer-mode-map
                ("C-c C-k" . skewer-load-buffer))
    :config
    (add-hook 'js2-mode-hook 'skewer-mode))
    #+end_src
*** js-comint
    #+begin_src emacs-lisp :tangle no
  (use-package js-comint
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
                (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
                (local-set-key (kbd "C-c b") 'js-send-buffer)
                (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
                (local-set-key (kbd "C-c l") 'js-load-file-and-go))))
    #+end_src
*** js-doc
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package js-doc
    :config
    (setq js-doc-mail-address "jethrokuan95@gmail.com"
          js-doc-author (format "Jethro Kuan <%s>" js-doc-mail-address)
          js-doc-url "http://www.jethrokuan.com/"
          js-doc-license "MIT")
    (add-hook 'js2-mode-hook
              #'(lambda ()
                  (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                  (define-key js2-mode-map "@" 'js-doc-insert-tag))))
#+END_SRC
*** JS2-refactor
    #+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-j"))
    #+end_src
*** Vue-mode
    Additional support for Vue.js projects.

    #+begin_src emacs-lisp :tangle yes
 (use-package vue-mode
   :mode "\\.vue\\'")
    #+end_src
** JSON
   #+begin_src emacs-lisp :tangle yes
 (use-package json-mode
   :mode "\\.json\\'"
   :config (add-hook 'json-mode-hook (lambda ()
                                       (make-local-variable 'js-indent-level)
                                       (setq js-indent-level 2))))
   #+end_src
** Markdown
   #+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :config (progn
            (setq markdown-command "multimarkdown")
            (add-hook 'markdown-mode-hook #'trunc-lines-hook)))
   #+end_src
** Clojure
*** Clojure-mode
    #+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode
    :mode (("\\.clj\\'" . clojure-mode)
           ("\\.boot\\'" . clojure-mode)
           ("\\.edn\\'" . clojure-mode)
           ("\\.cljs\\'" . clojurescript-mode)
           ("\\.cljs\\.hl\\'" . clojurescript-mode))
    :init
    (add-hook 'clojure-mode-hook #'eldoc-mode)
    (add-hook 'clojure-mode-hook #'subword-mode)
    (add-hook 'clojure-mode-hook #'cider-mode)
    (add-hook 'clojure-mode-hook #'clj-refactor-mode))
    #+end_src
*** Cider
    #+begin_src emacs-lisp :tangle yes
      (use-package cider
        :init
        (add-hook 'cider-mode-hook #'clj-refactor-mode)
        (add-hook 'cider-repl-mode-hook #'company-mode)
        (add-hook 'cider-mode-hook #'company-mode)
        :diminish subword-mode
        :config
        (setq nrepl-log-messages t                  
              cider-repl-display-in-current-window t
              cider-repl-use-clojure-font-lock t    
              cider-prompt-save-file-on-load 'always-save
              cider-font-lock-dynamically '(macro core function var)
              nrepl-hide-special-buffers t
              cider-show-error-buffer nil
              cider-overlays-use-font-lock t
              cider-repl-result-prefix ";; => ")
        (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
        (cider-repl-toggle-pretty-printing))
    #+end_src
*** clj-refactor
    #+begin_src emacs-lisp :tangle yes
(use-package clj-refactor
  :defines cljr-add-keybindings-with-prefix
  :diminish clj-refactor-mode
  :config (cljr-add-keybindings-with-prefix "C-c C-j"))
    #+end_src
*** Squiggly-clojure
    #+begin_src emacs-lisp :tangle yes
  (use-package flycheck-clojure
    :config
    (flycheck-clojure-setup))
    #+end_src
** Latex
*** AucTeX
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auctex
    :defer t
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-syntactic-comment t
          ;; Synctex support
          TeX-source-correlate-start-server nil
          ;; Don't insert line-break at inline math
          LaTeX-fill-break-at-separators nil)
    (setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) %o")
                                  ("qpdfview" "qpdfview %o#%(outpage)")))
    (setq TeX-view-program-selection '((output-pdf "qpdfview")
                                       (output-pdf "Evince")))
    (when latex-enable-auto-fill
      (add-hook 'LaTeX-mode-hook 'latex/auto-fill-mode))
    (when latex-enable-folding
      (add-hook 'LaTeX-mode-hook 'TeX-fold-mode))
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode))
    #+END_SRC
*** Autocomplete support
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-auctex
    :defer t)
    #+END_SRC
* Org Mode for GTD
This document aims to extensively document my implementation of
Getting Things Done, a methodology by David Allen. This will always be
a work-in-progress, and is *fully representative* of the GTD setup I
am currently using.

This document is written primarily for my own reference.
However, it is also written with readers who are looking for
inspiration when implementing GTD in org-mode.

** Reasoning 
There is no shortage of existing GTD implementations, in org-mode.
Perhaps the best reference document out there is by Bernt Hansen,
published [[http://doc.norang.ca/org-mode.html][here]]. However, there are some slight deviations from the GTD
that David Allen proposes, and some conveniences he takes making the
GTD system he implements weaker, that can perhaps be solved by writing
some Elisp. This is a major adaptation of his setup, but with
additional customizations that make it closer to the ideal system that
David Allen speaks about.

** Org-mode Setup
We use =org-plus-contrib=, which contains several contrib plugins that
may come in handy later, including =org-drill= and some =org-babel=
language support.

To install =org-plus-contrib=, one has to add the package archive to
Emacs. This is typically where you also add MELPA.

#+BEGIN_SRC emacs-lisp :tangle no
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (package-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org)
  (require 'bind-key)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c b" 'org-iswitchb)
  (bind-key "C-c c" 'org-capture)
#+END_SRC

** Organizing Your Life Into Org-mode Files
Bernt Hansen uses separate files as logical groups, such as a
separation between work and life. This may suit your purpose, but this
makes it a lot harder to write general Elisp code for. Once a new
logical group appears, the code that generates the weekly review would
have to change as well, for example.

Instead, I use David Allen's physical categories as different files,
and use org-mode tags to separate the different context. That is, I
have the files:

| file (.org) | Purpose                                                                                                                   |
|-------------+---------------------------------------------------------------------------------------------------------------------------|
| inbox       | Includes everything on your mind: tasks, ideas etc.                                                                       |
| someday     | Includes things that will be done later on (with no specific deadline), to be reviewed often                              |
| reference   | I don't actually have this file; I use [[http://jblevins.org/projects/deft/%5Ddeft-mode][deft-mode]] as my braindump                                                          |
| waiting     | This contains a list of names of people as level one headings, and things I'm waiting for them to complete as subheadings |
| next        | This contains one-off tasks that don't belong to projects.                                                                |
| projects    | This contains the list of projects, and their corresponding todo items                                                    |

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files '("~/.org/gtd/inbox.org"
                           "~/.org/gtd/someday.org"
                           "~/.org/gtd/projects.org"
                           "~/.org/gtd/tickler.org"))
#+END_SRC

** Stage 1: Collecting
Collecting needs to be convenient. This is achieved easily be using
=org-capture=. The capture template is kept simple, to minimize
friction in capturing new items as they pop up.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-capture-templates
        `(("i" "inbox" entry (file "~/.org/gtd/inbox.org")
           "* TODO %?
  Captured %<%Y-%m-%d %H:%M>")
          ("w" "Web site" entry (file "~/.org/deft/websites.org")
           "* %c\n" :immediate-finish t)))
#+END_SRC

** Stage 2: Processing
During predetermined times of each day, the inbox is to be processed,
each item in =inbox= sorted into their respective folders.

=org-agenda= provides a brilliant interface for viewing and processing
the inbox. At the end of the "processing" stage, =inbox.org= should be
empty, unless the processing is done on the whim. This will be
facilitated with an iOS or android app later on.

The process is clearly outlined in GTD, but key to the GTD
implementation here are a few factors:

1. *Which file*: Is this to be done someday when there's time, or is
   this a project (old or new), or is this a simple action?
2. *Adding of context*: Is this school-related, or work-related? Do I
   have to be at a specific location to perform this task?

At the end of the process, the item in =inbox= would have placed in
either a non-actionable file, or an actionable file (=projects=, or
=next=) with a physical actionable. To encourage this, we have a list
of verbs.

David Allen recommends processing inbox items top-down or bottom-up,
one item at a time. However, I like to have an overview of my inbox,
so I can estimate the number of items left to process.

This process is therefore contigent on several factors:
1. *There aren't too many items in the inbox at the same time.* This
   can prove to be too distracting. Fortunately, I've yet to
   experience this.
2. *Processing of inbox is more regular.* Keeping inbox zero at all
   times should be a goal, but not a priority.

*** Org Agenda Inbox View
This view is where I see all my inbox items: it is a simple list of
captured items in =inbox.org=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-agenda)
  (setq jethro/org-agenda-inbox-view
        `("i" "Inbox" todo ""
          ((org-agenda-files '("~/.org/gtd/inbox.org")))))
#+END_SRC

*** Org TODO Keywords
| keyword   | meaning                                                                      |
|-----------+------------------------------------------------------------------------------|
| TODO      | An item that has yet to be processed, or cannot be attempted at this moment. |
| NEXT      | An action that can be completed at this very moment, in the correct context  |
| DONE      | An item that is completed, and ready to be archived                          |
| WAITING   | An item that awaits input from an external party                             |
| HOLD      | An item that is delayed due to circumstance                                  |
| CANCELLED | An item that was once considered, but no longer to be attempted              |

=WAITING=, =HOLD=, and =CANCELLED= are all keywords that require
supplementary information. For example, who am I waiting for? Or why
is this item on hold? As such, it is convenient to trigger a note when
an item transitions to these states. Note that the triggers only
happen with "slow" state transitions, i.e. =C-c C-t=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))

  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-state-notes-insert-after-drawers nil)
#+END_SRC
*** The Process
**** Step 1: Clarifying
***** Tags
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-tag-alist (quote ((:startgroup)
                              ("@errand" . ?e)
                              ("@office" . ?o)
                              ("@home" . ?h)
                              ("@school" . ?s)
                              (:endgroup)
                              ("WAITING" . ?w)
                              ("HOLD" . ?H)
                              ("CANCELLED" . ?c))))

  (setq org-fast-tag-selection-single-key nil)

#+END_SRC
**** Step 2: Organizing
This step involves refiling the item in the appropriate location. We
set =org-refile-allow-creating-parent-nodes= to ='confirm=, because this
allows us to create new projects if there are no matches.

When capturing new projects, it helps to pen down a few things about
the project:

1. Project Purpose/Principles
2. Outcome Vision

This is currently done using =org-add-note=, but when my elisp-fu gets
stronger, I'd create a dedicated buffer with a template each time a
project is created.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; https://github.com/syl20bnr/spacemacs/issues/3094
  (setq org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-targets '(("someday.org" :maxlevel . 1)
                             ("projects.org" :maxlevel . 2)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun jethro/org-rename-item ()
    (interactive)
    (save-excursion
      (when (org-at-heading-p)
        (let* ((hl-text (nth 4 (org-heading-components)))
               (new-header (read-string "New Text: " nil nil hl-text)))
          (unless (or (null hl-text)
                      (org-string-match-p "^[ \t]*:[^:]+:$" hl-text))
            (beginning-of-line)
            (search-forward hl-text (point-at-eol))
            (replace-string
             hl-text
             new-header
             nil (- (point) (length hl-text)) (point)))))))

  (defun jethro/org-agenda-process-inbox-item (&optional goto rfloc no-update)
    (interactive "P") 
    (org-with-wide-buffer   
     (org-agenda-set-tags) 
     (org-agenda-refile nil nil t)
     (org-mark-ring-push)
     (org-refile-goto-last-stored)
     (jethro/org-rename-item)
     (org-mark-ring-goto)
     (org-agenda-redo)))

  (defun jethro/org-inbox-capture ()
    "Capture a task in agenda mode."
    (interactive)
    (org-capture nil "i"))

  (define-key org-agenda-mode-map "r" 'jethro/org-agenda-process-inbox-item)
  (define-key org-agenda-mode-map "c" 'jethro/org-inbox-capture)
#+END_SRC

***** TODO add advice
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar jethro/new-project-template
    "
      ,*Project Purpose/Principles*:

      ,*Project Outcome*:
      "
    "Project template, inserted when a new project is created")

  (defvar jethro/is-new-project nil
    "Boolean indicating whether it's during the creation of a new project")

  (defun jethro/refile-new-child-advice (orig-fun parent-target child)
    (let ((res (funcall orig-fun parent-target child)))
      (save-excursion
        (find-file (nth 1 parent-target))
        (goto-char (org-find-exact-headline-in-buffer child))
        (org-add-note)
        )
      res))

  (advice-add 'org-refile-new-child :around #'jethro/refile-new-child-advice)
#+END_SRC
** Stage 3: Reviewing
*** Custom agenda Commands
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-custom-commands
        `(,jethro/org-agenda-inbox-view
          ,jethro/org-agenda-todo-view))

  (setq jethro/org-agenda-todo-view
        `(" " "Agenda"
          ((agenda "" nil)
           (tags-todo "@school"
                      ((org-agenda-overriding-header "School")
                       (org-agenda-skip-function #'jethro/org-agenda-skip-all-siblings-but-first)))
           (tags-todo "@home"
                      ((org-agenda-overriding-header "Home")
                       (org-agenda-skip-function #'jethro/org-agenda-skip-all-siblings-but-first)))
           (tags-todo "@office"
                      ((org-agenda-overriding-header "Office")
                       (org-agenda-skip-function #'jethro/org-agenda-skip-all-siblings-but-first))) 
           (tags-todo "@errand"
                      ((org-agenda-overriding-header "Errands")
                       (org-agenda-skip-function #'jethro/org-agenda-skip-all-siblings-but-first)))
           nil)))

  (defun jethro/org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (or (org-current-is-todo)
                  (not (org-get-scheduled-time (point))))
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
             (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
#+END_SRC
** Stage 4: Doing

* Project Management
** Version Control
*** vc
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package vc
    :bind (:map jethro-mode-map
                ("C-x v =" . jethro/vc-diff)
                ("C-x v H" . vc-region-history)) ; New command in emacs 25.x
    :config
    (progn
      (defun jethro/vc-diff (no-whitespace)
        "Call `vc-diff' as usual if buffer is not modified.
  If the buffer is modified (yet to be saved), call `diff-buffer-with-file'.
  If NO-WHITESPACE is non-nil, ignore all white space when doing diff."
        (interactive "P")
        (let* ((no-ws-switch '("-w"))
               (vc-git-diff-switches (if no-whitespace
                                         no-ws-switch
                                       vc-git-diff-switches))
               (vc-diff-switches (if no-whitespace
                                     no-ws-switch
                                   vc-diff-switches))
               (diff-switches (if no-whitespace
                                  no-ws-switch
                                diff-switches))
               ;; Set `current-prefix-arg' to nil so that the HISTORIC arg
               ;; of `vc-diff' stays nil.
               current-prefix-arg)
          (if (buffer-modified-p)
              (diff-buffer-with-file (current-buffer))
            (call-interactively #'vc-diff))))))
#+END_SRC
*** Smerge-mode
Useful when handling git merge conflicts.

#+begin_src emacs-lisp :tangle yes
  (use-package smerge-mode
    :bind (:map jethro-mode-map
                ("C-c h s" . jethro/hydra-smerge/body))
    :init
    (progn
      (defun jethro/enable-smerge-maybe ()
        "Auto-enable `smerge-mode' when merge conflict is detected."
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^<<<<<<< " nil :noerror)
            (smerge-mode 1))))
      (add-hook 'find-file-hook #'jethro/enable-smerge-maybe :append))
    :config 
    (defalias 'smerge-keep-upper 'smerge-keep-mine)
    (defalias 'smerge-keep-lower 'smerge-keep-other)
    (defalias 'smerge-diff-base-upper 'smerge-diff-base-mine)
    (defalias 'smerge-diff-upper-lower 'smerge-diff-mine-other)
    (defalias 'smerge-diff-base-lower 'smerge-diff-base-other)

    (defhydra jethro/hydra-smerge (:color pink
                                          :hint nil
                                          :pre (smerge-mode 1)
                                          ;; Disable `smerge-mode' when quitting hydra if
                                          ;; no merge conflicts remain.
                                          :post (smerge-auto-leave))
      "
     ^Move^       ^Keep^               ^Diff^                 ^Other^
     ^^-----------^^-------------------^^---------------------^^-------
     _n_ext       _b_ase               _<_: upper/base        _C_ombine
     _p_rev       _u_pper              _=_: upper/lower       _r_esolve
     ^^           _l_ower              _>_: base/lower        _k_ill current
     ^^           _a_ll                _R_efine
     ^^           _RET_: current       _E_diff
     "
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("k" smerge-kill-current)
      ("q" nil "cancel" :color blue)))
#+end_src
*** Magit
 #+begin_src emacs-lisp :tangle yes
   (use-package magit
     :bind (:map jethro-mode-map
                 ("s-g" . magit-status)
                 ("C-c g" . magit-status)
                 ("s-G" . magit-blame)
                 ("C-c G" . magit-blame))
     :init
     (add-hook 'magit-mode-hook 'hl-line-mode)
     :config
     (setq magit-auto-revert-mode nil))
 #+end_src
** Projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :demand t
    :init (projectile-global-mode 1)
    :bind-keymap* ("C-x p" . projectile-command-map)
    :config
    (require 'projectile)
    (use-package counsel-projectile 
      :bind (:map jethro-mode-map
                  ("s-f" . counsel-projectile-find-file)
                  ("s-b" . counsel-projectile-switch-to-buffer))
      :config
      (counsel-projectile-on))
    (setq projectile-use-git-grep t)
    (setq projectile-create-missing-test-files t)
    (setq projectile-completion-system 'ivy)

    (setq projectile-switch-project-action
          #'projectile-commander)
    (def-projectile-commander-method ?S
      "Run a search in the project"
      (counsel-projectile-rg))
    (def-projectile-commander-method ?s
      "Open a *eshell* buffer for the project."
      (projectile-run-eshell))
    (def-projectile-commander-method ?d
      "Open project root in dired."
      (projectile-dired))
    (def-projectile-commander-method ?g
      "Show magit status."
      (magit-status))
    (def-projectile-commander-method ?j
      "Jack-in."
      (let* ((opts (projectile-current-project-files))
             (file (ivy-read
                    "Find file: " 
                    opts)))
        (find-file (expand-file-name
                    file (projectile-project-root)))
        (run-hooks 'projectile-find-file-hook)
        (cider-jack-in))))
#+end_src
* Miscellaneous
** SOS
Search Stack Overflow
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sos
    :commands (sos))
#+END_SRC
** which-key
#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :diminish which-key-mode
    :init
    (add-hook 'after-init-hook 'which-key-mode))
#+end_src
** darkroom
#+begin_src emacs-lisp :tangle yes
  (use-package darkroom
    :bind (:map jethro-mode-map
                ("C-c M d" . darkroom-mode)
                ("C-c M t" . darkroom-tentative-mode)))
#+end_src
** bury-successful-compilation
Closes compile buffer if there are no errors.
#+begin_src emacs-lisp :tangle yes
  (use-package bury-successful-compilation
    :init
    (add-hook 'after-init-hook 'bury-successful-compilation))
#+end_src
