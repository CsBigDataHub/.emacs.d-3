#+TITLE: Jethro's Emacs Configuration
#+PROPERTY: header-args :tangle yes

* Introduction

This document is a constant work-in-progress, and will contain the
latest updates to my Emacs configuration.

If you have want to contact me for any reason, you can reach me at my
email: =jethrokuan95@gmail.com=.

Notes:
1. I use a Dvorak 60% keyboard, so some of the keybindings may not be
   suitable for you.
2. I use [[http://www.nongnu.org/ratpoison/][Ratpoison]], and many of my keybindings are designed around
   that.

** Why Emacs?

I've used vim for slightly under 5 years, and have switched to emacs
since Aug 2016, when I first started dabbling with Clojure. I've stuck
to Emacs for the following reasons:

1. Emacs is flexible. Emacs Lisp makes it a joy to extend, attracting
   a large community of lisp hackers. Case in point: [[https://sites.google.com/site/steveyegge2/tour-de-babel][Amazon's Customer
   Service application Mailman was built in Emacs Lisp]].
2. Emacs provides a uniform interface. Everything is text, everything
   is in a buffer. Keyboard movements work everywhere, no surprises.
3. Emacs has everything you need. It has a web browser (eww), irc
   client (erc/irc), email client (mu4e/notmuch/gnus), file browser
   (dired) and many more. I've found little need for applications
   outside of Emacs, other than Firefox.
4. Emacs has [[https://orgmode.org/][org-mode]]. This gorgeous piece of software has proven to
   be indispensable.

* About the Author

I'm currently a Computer Science undergraduate at the National
University of Singapore. My configuration centers around my daily
Emacs usage, which involves:

1. Backend development (primarily in Python and JS)
2. Frontend development (HTML/CSS/JS/React)
3. ML/DL stuff (Python)
4. Email (notmuch)
5. RSS (elfeed + elfeed-org)
6. Getting Things Done (org-mode)

#+begin_src emacs-lisp
  (setq user-full-name "Jethro Kuan"
        user-mail-address "jethrokuan95@gmail.com")
#+end_src

* Preinit: [[https://github.com/jwiegley/use-package/issues/70][use-package]]

Use-package allows for isolation of package configuration, while
maintaining tidiness and performance.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (if (memq window-system '(mac ns))
      (progn
        (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
        (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))
    (setq package-archives nil))

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

  ;; Always demand if daemon-mode
  (setq use-package-always-demand (daemonp))

#+END_SRC

* Add PATH to shell
Only if on Mac OSX.
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure f
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

* Better Defaults

** Function Redefinition

Some warnings are generated when functions are redefined via
=defadvice=. For example:

#+BEGIN_QUOTE
ad-handle-definition: `tramp-read-passwd' got redefined
#+END_QUOTE

To suppress these warnings, we accept these redefinitions:

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

** No littering

This package sets out to fix this by changing the values of path
variables to put files in either =no-littering-etc-directory=
(defaulting to ~/.emacs.d/etc/) or =no-littering-var-directory=
(defaulting to ~/.emacs.d/var/), and by using descriptive file names
and subdirectories when appropriate. 

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :config
    (require 'recentf)
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+END_SRC

** Emacs GC settings

Reduce the frequency of garbage collection by making it happen on each
50MB of allocated data (the default is on every 0.76MB). Also, warn
when opening large files.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 50000000)
  (setq large-file-warning-threshold 100000000)
#+END_SRC

** Auto Revert

Often when switching git branches, files tend to change. By default,
Emacs does not revert the buffers affected, which can lead to some
confusion. Turn on =auto-revert-mode= globally, so that when the files
change, the buffers reflect the latest editions as well.

NOTE: This can be quite slow, when the changes are massive across
branches.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure f
    :diminish t
    :hook
    (dired-mode . auto-revert-mode)
    :config
    (global-auto-revert-mode +1)
    :custom
    (auto-revert-verbose nil))
#+END_SRC
** Custom file

Using the customize interface can be nice, but it tends to pollute
=init.el=. Move all customizations to a separate file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
#+END_SRC

** Use y/n over yes/no

y/n is easier to type than yes/no

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Replace region when typing

Type over a selected region, instead of deleting before typing.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+end_src

** Editing Preferences

Emacs uses double-spaces by default. Use single spaces instead:

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

Also, use 2 spaces for tabs. Death to tabs!

#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default js-indent-level 2)
  (setq-default indent-tabs-mode nil)
#+end_src

** Line wrapping for text modes

Don't wrap lines for coding. Create a hook that enables wrapping, for
text-modes like org-mode and markdown-mode.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)

  (defun jethro/truncate-lines-hook ()
    (setq truncate-lines nil))

  (add-hook 'text-mode-hook 'jethro/truncate-lines-hook)
#+end_src

** No lockfiles
Emacs creates lock files to make sure that only one instance of emacs
is editing a particular file. However, this often interferes with some
of the language server stuff that facilitates auto-completion, among
other things. Since I use the emacs daemon, I won't face these issues,
and hence I turn it off.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

** goto-addr
#+BEGIN_SRC emacs-lisp
  (use-package goto-addr
    :hook ((compilation-mode . goto-address-mode)
           (prog-mode . goto-address-prog-mode)
           (eshell-mode . goto-address-mode)
           (shell-mode . goto-address-mode))
    :bind (:map goto-address-highlight-keymap
                ("<RET>" . goto-address-at-point)
                ("M-<RET>" . newline))
    :commands (goto-address-prog-mode
               goto-address-mode))
#+END_SRC

** Bury buffers
This puts the buffer at the end of the list for all buffers, making it
the least likely candidate for buffer selection. I bind this to ~C-z~
which is the default keybinding for suspending a frame, which I don't
use.

#+begin_src emacs-lisp
  (bind-key "C-z" 'bury-buffer)
#+end_src

** Automatic chmod +x
#+begin_src emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

* Email
Managing email in emacs is not so simple. Thankfully, I use NixOS, which
provides a reproducible environment for my email setup. You can see it
[[https://github.com/jethrokuan/nix-config/blob/master/modules/email.nix][here]]. 

The setup involves running mbsync every 5 minutes for a bidirectional
sync using the IMAP protocol. I use Gmail as my mail store, and ~pass~
to provide my account credentials.

[[https://github.com/jethrokuan/dotfiles/tree/master/mbsync][mbsync configuration]]

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :preface (setq-default notmuch-command (executable-find "notmuch"))
    :if (executable-find "notmuch")
    :bind (("<f2>" . notmuch)
           :map notmuch-search-mode-map
           ("t" . jethro/notmuch-toggle-read)
           ("r" . notmuch-search-reply-to-thread)
           ("R" . notmuch-search-reply-to-thread-sender)
           :map notmuch-show-mode-map
           ("l" . jethro/notmuch-show-jump-to-latest)
           ("<tab>" . org-next-link)
           ("<backtab>". org-previous-link)
           ("C-<return>" . browse-url-at-point))
    :config
    (defun jethro/notmuch-toggle-read ()
      "toggle read status of message"
      (interactive)
      (if (member "unread" (notmuch-search-get-tags))
          (notmuch-search-tag (list "-unread"))
        (notmuch-search-tag (list "+unread"))))
    (defun jethro/notmuch-show-jump-to-latest ()
      "Jump to the message in the current thread with the latest
  timestamp."
      (interactive)
      (let ((timestamp 0)
            latest)
        (notmuch-show-mapc
         (lambda () (let ((ts (notmuch-show-get-prop :timestamp)))
                      (when (> ts timestamp)
                        (setq timestamp ts
                              latest (point))))))
        (if latest
            (goto-char latest)
          (error "Cannot find latest message."))))
    :custom
    (message-auto-save-directory "~/.mail/drafts/")
    (message-send-mail-function 'message-send-mail-with-sendmail)
    (sendmail-program (executable-find "msmtp"))

    ;; We need this to ensure msmtp picks up the correct email account
    (message-sendmail-envelope-from 'header)
    (mail-envelope-from 'header)
    (mail-specify-envelope-from t)
    (message-sendmail-f-is-evil nil)
    (message-kill-buffer-on-exit t)
    (notmuch-always-prompt-for-sender t)
    (notmuch-archive-tags '("-inbox" "-unread"))
    (notmuch-crypto-process-mime t)
    (notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
    (notmuch-labeler-hide-known-labels t)
    (notmuch-search-oldest-first nil)
    (notmuch-archive-tags '("-inbox" "-unread"))
    (notmuch-message-headers '("To" "Cc" "Subject" "Bcc"))
    (notmuch-saved-searches '((:name "unread" :query "tag:unread")
                              (:name "to-me" :query "tag:to-me")
                              (:name "sent" :query "tag:sent")
                              (:name "personal" :query "tag:personal")
                              (:name "nushackers" :query "tag:nushackers")
                              (:name "nus" :query "tag:nus")
                              (:name "drafts" :query "tag:draft"))))
#+END_SRC
** Org-mode Integration
I use org-mode to manage everything. ~org-notmuch~ provides the
facility to capture email into a task.

#+BEGIN_SRC emacs-lisp
  (use-package org-notmuch
    :ensure f
    :after org notmuch
    :bind
    (:map notmuch-show-mode-map
          ("C" . jethro/org-capture-email))
    :config
    (defun jethro/org-capture-email ()
      (interactive)
      (org-capture nil "e")))
#+END_SRC
** Modeline
#+begin_src emacs-lisp
  (use-package notmuch-unread
    :after all-the-icons
    :load-path "./elisp/notmuch-unread/"
    :hook
    (after-init . notmuch-unread-mode))
#+end_src

* Appearance
** Font
I use [[https://github.com/be5invis/Iosevka][Iosevka]]. Other good free alternatives include Source Code Pro,
Office Code Pro and the Powerline font families.

#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((font . "Iosevka-14")))
#+END_SRC

** Removing UI Cruft
Remove the useless toolbars and splash screens.

#+begin_src emacs-lisp
  (when (fboundp 'tooltip-mode)
    (tooltip-mode -1))
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+end_src

** Theme
*** Tao-theme
#+BEGIN_SRC emacs-lisp
  (use-package tao-theme
    :init
    (load-theme 'tao-yang t))
#+END_SRC

** Rainbow-delimiters-mode
   We use rainbow delimiters to show imbalanced parenthesis.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :defer 5
    :hook
    (prog-mode . rainbow-delimiters-mode)
    :config
    (rainbow-delimiters-mode +1)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error))
#+END_SRC

** Remove blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** hl-todo
Simple minor mode that highlights the todo keywords.

#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :defer 5
    :config
    (global-hl-todo-mode))
#+END_SRC

* Reading feeds with elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :bind
    (("<f6>" . elfeed))
    :custom
    (shr-width 80))
#+END_SRC
** elfeed-org
#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :after elfeed
    :bind
    (:map elfeed-show-mode-map
          ("C" . jethro/org-capture-elfeed-link))
    (:map elfeed-search-mode-map
          ("C" . jethro/org-capture-elfeed-link))
    :config
    (require 'elfeed-link)
    (elfeed-org)
    (defun jethro/org-capture-elfeed-link ()
      (interactive)
      (org-capture nil "z"))
    :custom
    (rmh-elfeed-org-files '("~/.org/deft/feeds.org")))
#+END_SRC
* Ivy
Ivy is generic completion frontend for Emacs. Ivy is more efficient,
simpler and more customizable.
** Counsel
Counsel contains ivy enhancements for commonly-used functions.
#+begin_src emacs-lisp
  (use-package counsel
    :hook
    (after-init . ivy-mode)
    :diminish ivy-mode
    :bind
    (("C-c C-r" . ivy-resume)
     ("M-x" . counsel-M-x)
     ("C-c i" . counsel-imenu)
     ("C-x b" . ivy-switch-buffer)
     ("C-x B" . ivy-switch-buffer-other-window)
     ("C-x k" . kill-buffer)
     ("C-x C-f" . counsel-find-file)
     ("C-x l" . counsel-locate)
     ("C-c j" . counsel-git)
     ("M-y" . counsel-yank-pop)
     :map help-map
     ("f" . counsel-describe-function)
     ("v" . counsel-describe-variable)
     ("l" . counsel-info-lookup-symbol)
     :map ivy-minibuffer-map
     ("C-o" . ivy-occur)
     ("<return>" . ivy-alt-done)
     ("M-<return>" . ivy-immediate-done)
     :map read-expression-map
     ("C-r" . counsel-minibuffer-history))
    :custom
    (counsel-find-file-at-point t)
    (ivy-use-virtual-buffers t)
    (ivy-display-style 'fancy)
    (ivy-use-selectable-prompt t)
    (ivy-re-builders-alist
     '((ivy-switch-buffer . ivy--regex-plus)
       (swiper . ivy--regex-plus)
       (t . ivy--regex-fuzzy)))
    :config
    (ivy-set-actions
     t
     '(("I" insert "insert")))
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
   #+end_src

#+begin_src emacs-lisp
  (use-package counsel-fd
    :after counsel
    :if (executable-find "notmuch")
    :load-path "./elisp/counsel-fd/"
    :bind
    (("C-x j" . counsel-fd-dired-jump)
     ("C-x f" . counsel-fd-file-jump)))
#+end_src

** Swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind
    (("C-s" . swiper-isearch)
     ("C-r" . swiper-isearch)
     ("C-c C-s" . counsel-grep-or-swiper)
     :map swiper-map
     ("M-q" . swiper-query-replace)
     ("C-l". swiper-recenter-top-bottom)
     ("C-'" . swiper-avy))
    :custom
    (counsel-grep-swiper-limit 20000)
    (counsel-rg-base-command
     "rg -i -M 120 --no-heading --line-number --color never %s .")
    (counsel-grep-base-command
     "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))
#+END_SRC

** wgrep
    wgrep allows you to edit a grep buffer and apply those changes to the
    file buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package wgrep
        :commands
        wgrep-change-to-wgrep-mode
        ivy-wgrep-change-to-wgrep-mode)
    #+END_SRC
** deadgrep
    #+BEGIN_SRC emacs-lisp
      (use-package deadgrep
        :if (executable-find "rg")
        :bind* (("M-s" . deadgrep)))
    #+END_SRC
* Hydras
#+begin_src emacs-lisp
  (use-package hydra
    :config
    (defhydra jethro/hydra-zoom ()
      "zoom"
      ("i" text-scale-increase "in")
      ("o" text-scale-decrease "out"))

    (bind-key "C-c h z" 'jethro/hydra-zoom/body))
#+end_src
* Visual Enhancements
** Whitespace-mode
#+begin_src emacs-lisp
  (use-package whitespace
    :ensure f
    :diminish whitespace-mode
    :hook (prog-mode . whitespace-mode)
    :custom
    (whitespace-line-column 80)
    (whitespace-style '(face lines-tail)))
#+end_src
** Moody
#+BEGIN_SRC emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode)
    :custom-face
    (mode-line ((t
                 (:height 1.0 :box nil :foreground "#292617" :background "#ECE9E0")))))
#+END_SRC
** Minions
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config
    (minions-mode +1))
#+END_SRC
** beacon
   Beacon makes sure you don't lose track of your cursor when jumping around a buffer.

   #+begin_src emacs-lisp
     (use-package beacon
       :defer 10
       :diminish beacon-mode
       :custom
       (beacon-push-mark 10)
       :config
       (beacon-mode +1))
   #+end_src

** Show Matching parenthesis
   Always show matching parenthesis.
   #+begin_src emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
   #+end_src

** volatile-highlights
   Highlights recently copied/pasted text.

   #+begin_src emacs-lisp
     (use-package volatile-highlights
       :defer 5
       :diminish volatile-highlights-mode
       :config
       (volatile-highlights-mode +1))
   #+end_src

** diff-hl
   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :defer 3
       :hook
       (dired-mode . diff-hl-dired-mode)
       :init
       (defconst jethro/diff-hl-mode-hooks '(emacs-lisp-mode-hook
                                             conf-space-mode-hook ;.tmux.conf
                                             markdown-mode-hook
                                             css-mode-hook
                                             web-mode-hook
                                             sh-mode-hook
                                             python-mode-hook
                                             yaml-mode-hook ;tmuxp yaml configs
                                             c-mode-hook)
         "List of hooks of major modes in which diff-hl-mode should be enabled.")

       (dolist (hook jethro/diff-hl-mode-hooks)
         (add-hook hook #'diff-hl-flydiff-mode)))

     (use-package diff-hl-hydra
       :ensure f
       :after hydra
       :no-require t
       :config
       (defhydra jethro/hydra-diff-hl (:color red)
         "diff-hl"
         ("=" diff-hl-diff-goto-hunk "goto hunk")
         ("<RET>" diff-hl-diff-goto-hunk "goto hunk")
         ("u" diff-hl-revert-hunk "revert hunk")
         ("[" diff-hl-previous-hunk "prev hunk")
         ("p" diff-hl-previous-hunk "prev hunk")
         ("]" diff-hl-next-hunk "next hunk")
         ("n" diff-hl-next-hunk "next hunk")
         ("q" nil "cancel"))

       (bind-key "C-c h v" #'jethro/hydra-diff-hl/body))
   #+END_SRC
* Moving Around
** Eyebrowse
   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse
       :bind* (("M-0" . eyebrowse-switch-to-window-config-0)
               ("M-1" . eyebrowse-switch-to-window-config-1)
               ("M-2" . eyebrowse-switch-to-window-config-2)
               ("M-3" . eyebrowse-switch-to-window-config-3)
               ("M-4" . eyebrowse-switch-to-window-config-4)
               ("M-5" . eyebrowse-switch-to-window-config-5)
               ("M-6" . eyebrowse-switch-to-window-config-6)
               ("M-7" . eyebrowse-switch-to-window-config-7)
               ("M-8" . eyebrowse-switch-to-window-config-8)
               ("M-9" . eyebrowse-switch-to-window-config-9))
       :config
       (eyebrowse-mode +1))
   #+END_SRC
** Crux
#+begin_src emacs-lisp
  (use-package crux
    :bind (("C-c o" . crux-open-with)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-a" . crux-move-beginning-of-line)
           ("M-o" . crux-smart-open-line)
           ("C-c r" . crux-rename-file-and-buffer)
           ("M-D" . crux-duplicate-and-comment-current-line-or-region)
           ("s-o" . crux-smart-open-line-above)))
#+end_src
** avy
Use avy to move between visible text.
#+begin_src emacs-lisp
  (use-package avy
    :bind*
    (("C-'" . avy-goto-char-timer))
    :custom
    (avy-keys '(?h ?t ?n ?s ?m ?w ?v ?z)))
#+end_src
** smart-jump
This packages tries to smartly go to definition leveraging several
methods to do so.

If one method fails, this package will go on to the next one,
eventually falling back to dumb-jump.
#+BEGIN_SRC emacs-lisp
  (use-package smart-jump
    :defer 5
    :config
    (smart-jump-setup-default-registers))
#+END_SRC
** Dired
*** Dired for Mac OSX
Dired requires GNU ls output, so gls needs to be installed on OSX for
it to work properly.

#+BEGIN_SRC emacs-lisp
  (let ((gls "/usr/local/bin/gls"))
    (if (file-exists-p gls)
        (setq insert-directory-program gls)))
#+END_SRC
*** Sort directories first
    #+begin_src emacs-lisp
(setq dired-listing-switches "-aBhl  --group-directories-first")
    #+end_src
*** Enable dired-dwim
This allows dired to copy/paste/move files over to the other directory
in a separate window pane quickly.

#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t)
#+END_SRC
*** Recursive Copying and Deleting
    #+begin_src emacs-lisp
  (setq dired-recursive-copies (quote always))
  (setq dired-recursive-deletes (quote top))
    #+end_src

*** allow editing of permissions
#+BEGIN_SRC emacs-lisp
  (use-package wdired
    :commands wdired-mode wdired-change-to-wdired-mode
    :custom
    (wdired-allow-to-change-permissions t))
#+END_SRC

*** dired-narrow
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("N" . dired-narrow-fuzzy)))
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (([remap list-buffers] . ibuffer))
    :custom
    (ibuffer-expert t))
#+END_SRC

** shackle
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :diminish shackle-mode
    :if (not (bound-and-true-p disable-pkg-shackle))
    :custom
    (shackle-rules 
     '((compilation-mode :select nil)
       ("*undo-tree*" :size 0.25 :align right)
       ("*eshell*" :select t :size 0.3 :align t)
       ("*Shell Command Output*" :select nil)
       ("\\*Async Shell.*\\*" :regexp t :ignore t)
       (occur-mode :select nil :align t)
       ("*Help*" :select t :inhibit-window-quit t :other t)
       ("*Completions*" :size 0.3 :align t)
       ("*Messages*" :select nil :inhibit-window-quit t :other t)
       ("\\*[Wo]*Man.*\\*" :regexp t :select t :inhibit-window-quit t :other t) 
       ("*Calendar*" :select t :size 0.3 :align below)
       ("*info*" :select t :inhibit-window-quit t :same t)
       (magit-status-mode :select t :inhibit-window-quit t :same t)
       (magit-log-mode :select t :inhibit-window-quit t :same t)))
    :config
    (shackle-mode +1))
#+END_SRC

* Editing Text
** easy-kill
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
    :bind*
    (([remap kill-ring-save] . easy-kill)))
#+END_SRC
** aggressive-indent
Keep your text indented at all times. Remember to turn this off for indentation-dependent languages like Python and Haml.
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :config
    (global-aggressive-indent-mode +1)
    :custom
    (aggressive-indent-excluded-modes
     '(bibtex-mode
       cider-repl-mode
       c-mode
       c++-mode     
       coffee-mode
       comint-mode
       conf-mode
       Custom-mode
       diff-mode
       doc-view-mode
       dos-mode
       erc-mode
       jabber-chat-mode
       haml-mode
       intero-mode
       haskell-mode
       interative-haskell-mode
       haskell-interactive-mode
       image-mode
       makefile-mode
       makefile-gmake-mode
       minibuffer-inactive-mode
       nix-mode
       netcmd-mode
       python-mode
       sass-mode
       slim-mode
       special-mode
       shell-mode
       snippet-mode
       eshell-mode
       tabulated-list-mode
       term-mode
       TeX-output-mode
       text-mode
       yaml-mode
       scala-mode)))
#+end_src
** multiple-cursors
A port of Sublime Text's multiple-cursors functionality.
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-M-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)))
#+end_src
** expand-region
Use this often, and in combination with multiple-cursors.
#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-=" . er/expand-region)))
#+end_src

** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :hook
    (after-init . smartparens-global-strict-mode)
    :bind (:map smartparens-mode-map
                ("C-M-f" . sp-forward-sexp)
                ("C-M-b" . sp-backward-sexp)
                ("C-M-u" . sp-backward-up-sexp)
                ("C-M-d" . sp-down-sexp)
                ("C-M-p" . sp-backward-down-sexp)
                ("C-M-n" . sp-up-sexp)
                ("C-M-s" . sp-splice-sexp)
                ("C-M-<up>" . sp-splice-sexp-killing-backward)
                ("C-M-<down>" . sp-splice-sexp-killing-forward)
                ("C-M-r" . sp-splice-sexp-killing-around)
                ("C-)" . sp-forward-slurp-sexp)
                ("C-<right>" . sp-forward-slurp-sexp)
                ("C-}" . sp-forward-barf-sexp)
                ("C-<left>" . sp-forward-barf-sexp)
                ("C-(" . sp-backward-slurp-sexp)
                ("C-M-<left>" . sp-backward-slurp-sexp)
                ("C-{" . sp-backward-barf-sexp)
                ("C-M-<right>" . sp-backward-barf-sexp)
                ("M-S" . sp-split-sexp))
    :config
    (require 'smartparens-config)
    ;; Org-mode config
    (sp-with-modes 'org-mode
      (sp-local-pair "'" nil :unless '(sp-point-after-word-p))
      (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
      (sp-local-pair "_" "_" :unless '(sp-point-after-word-p))
      (sp-local-pair "/" "/" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "«" "»"))

    (defun sp--org-skip-asterisk (ms mb me)
      (or (and (= (line-beginning-position) mb)
               (eq 32 (char-after (1+ mb))))
          (and (= (1+ (line-beginning-position)) me)
               (eq 32 (char-after me))))))
#+end_src
** zap-up-to-char
   #+begin_src emacs-lisp
     (autoload 'zap-up-to-char "misc"
       "Kill up to, but not including ARGth occurrence of CHAR.

       \(fn arg char)"
       'interactive)

     (bind-key "M-z" 'zap-up-to-char)
   #+end_src
** ws-butler
Only lines touched get trimmed. If the white space at end of buffer is
changed, then blank lines at the end of buffer are truncated
respecting require-final-newline. Trimming only happens when saving.
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish 'ws-butler-mode
    :hook
    (prog-mode . ws-butler-mode))
#+END_SRC
** Linting with Flycheck
   #+begin_src emacs-lisp 
     (use-package flycheck
       :config
       (global-flycheck-mode +1)

       (setq-default flycheck-check-syntax-automatically '(save
                                                           idle-change
                                                           mode-enabled))

       ;; Temporary workaround: Direnv needs to load PATH before flycheck looks
       ;; for linters
       (setq flycheck-executable-find
             (lambda (cmd)
               (direnv-update-environment default-directory)
               (executable-find cmd))))

     (use-package flycheck-hydra
       :ensure f
       :no-require t
       :after flycheck hydra
       :config
       (defhydra jethro/hydra-flycheck
         (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
               :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
               :hint nil)
         "Errors"
         ("f"  flycheck-error-list-set-filter                            "Filter")
         ("n"  flycheck-next-error                                       "Next")
         ("p"  flycheck-previous-error                                   "Previous")
         ("<" flycheck-first-error                                      "First")
         (">"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
         ("q"  nil))

       (bind-key "C-c h f" #'jethro/hydra-flycheck/body))

     (use-package flycheck-pos-tip
       :after flycheck
       :hook
       (flycheck-mode . flycheck-pos-tip-mode))
   #+end_src
*** Proselint
By default proselint doesn't support org-mode, which is where I write
the bulk of my text, so I'm redefining the checker here.

#+BEGIN_SRC emacs-lisp 
  (flycheck-add-mode 'proselint 'org-mode)
#+END_SRC
** Templating with Yasnippet
   #+begin_src emacs-lisp 
     (use-package yasnippet
       :diminish yas-global-mode yas-minor-mode
       :config
       (yas-global-mode +1)
       :custom
       (yas-snippet-dirs '("~/.emacs.d/snippets/snippets/")))
   #+end_src
** Autocompletions with Company
#+begin_src emacs-lisp 
  (use-package company
    :defer 3
    :diminish company-mode
    :bind (:map company-active-map
                ("M-n" . nil)
                ("M-p" . nil)
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous))
    :custom
    (company-dabbrev-ignore-case nil)
    (company-dabbrev-code-ignore-case nil)
    (company-dabbrev-downcase nil)
    (company-idle-delay 0.5)
    (company-minimum-prefix-length 2)
    (company-require-match nil)
    (company-begin-commands '(self-insert-command))
    (company-transformers '(company-sort-by-occurrence))
    :config
    (defun company-mode/backend-with-yas (backend)
      (if (and (listp backend) (member 'company-yasnippet backend))
          backend
        (append (if (consp backend) backend (list backend))
                '(:with company-yasnippet))))

    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
    (global-company-mode +1))

  (use-package company-quickhelp
    :after company
    :bind (:map company-active-map
                ("M-h" . company-quickhelp-manual-begin))
    :hook
    (company-mode . company-quickhelp-mode))
#+end_src

** Spellcheck with Flyspell
#+begin_src emacs-lisp 
  (use-package flyspell 
    :ensure f
    :diminish flyspell-mode
    :init
    (setenv "DICTIONARY" "en_GB")
    :hook
    (text-mode . flyspell-mode)
    :custom
    (flyspell-abbrev-p t))

  (use-package flyspell-correct
    :bind
    (:map flyspell-mode-map
          (("C-;" . flyspell-correct-wrapper))))

  (use-package flyspell-correct-ivy
    :after flyspell-correct)
#+end_src
** Auto-fill-mode
#+BEGIN_SRC emacs-lisp 
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'message-mode-hook (lambda ()
                                 (auto-fill-mode -1)))
  (diminish 'auto-fill-mode)
#+END_SRC
** Hippie Expand
#+BEGIN_SRC emacs-lisp 
  (bind-key "M-/" 'hippie-expand)

  (setq hippie-expand-try-functions-list
        '(yas-hippie-try-expand
          try-expand-all-abbrevs
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-dabbrev
          try-expand-dabbrev-from-kill
          try-expand-dabbrev-all-buffers
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
#+END_SRC
** Fill and unfill paragraphs
Stolen from http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html.
#+BEGIN_SRC emacs-lisp 
  (defun endless/fill-or-unfill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
           (if (eq last-command 'endless/fill-or-unfill)
               (progn (setq this-command nil)
                      (point-max))
             fill-column)))
      (call-interactively #'fill-paragraph)))

  (global-set-key [remap fill-paragraph]
                  #'endless/fill-or-unfill)
#+END_SRC
** dtrt-indent
dtrt-indent guesses the indentation settings of files, and sets the
buffer local variables accordingly. This makes it pleasant to edit
corresponding text files.

#+BEGIN_SRC emacs-lisp 
  (use-package dtrt-indent
    :diminish t
    :config
    (dtrt-indent-mode +1))
#+END_SRC
* Direnv
#+BEGIN_SRC emacs-lisp 
  (use-package direnv
    :if (executable-find "direnv")
    :custom
    (direnv-always-show-summary nil)
    :config
    (direnv-mode +1))
#+END_SRC
* Languages
** Language Servers
#+BEGIN_SRC emacs-lisp 
  (use-package lsp-mode
    :commands lsp
    :hook
    (lsp-after-open-hook . lsp-enable-imenu)
    :custom
    (lsp-message-project-root-warning t)
    :init
    (require 'lsp-clients)
    (add-hook 'python-mode-hook #'lsp)
    (add-hook 'c++-mode-hook #'lsp)
    (add-hook 'c-mode-hook #'lsp))

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :hook
    (lsp-mode . lsp-ui-mode)
    :config
    (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
    (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references))

  (use-package company-lsp
    :after company lsp-mode
    :config
    (add-to-list 'company-backends 'company-lsp))
#+END_SRC

** Emacs Lisp
#+begin_src emacs-lisp 
  (bind-key "C-c C-k" 'eval-buffer emacs-lisp-mode-map)
#+end_src
** Elixir
*** elixir-mode
#+BEGIN_SRC emacs-lisp 
  (use-package elixir-mode
    :mode "\\.ex[s]?\\'")
#+END_SRC
*** Alchemist
#+BEGIN_SRC emacs-lisp 
  (use-package alchemist
    :after elixir-mode)
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp 
  (use-package docker
    :commands docker-mode)

  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
#+END_SRC
** Nix
#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode ("\\.nix\\'" "\\.nix.in\\'")
    :custom
    (nix-indent-function #'nix-indent-line))

  (use-package nix-drv-mode
    :ensure nix-mode
    :mode "\\.drv\\'")

  (use-package nix-shell
    :ensure nix-mode
    :commands (nix-shell-unpack nix-shell-configure nix-shell-build))

  (use-package nix-repl
    :ensure nix-mode
    :commands (nix-repl))

  (use-package nix-update
    :after nix-mode
    :bind
    (:map nix-mode-map
          ("C-. u" . nix-update)))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp 
  (use-package haskell-mode
    :mode ("\\.hs\\'" . haskell-mode)
    :init
    (add-hook 'haskell-mode-hook
              (lambda ()
                (setq compile-command "stack build --fast --test --bench --no-run-tests --no-run-benchmarks"))))
#+END_SRC
*** Intero
#+BEGIN_SRC emacs-lisp 
  (use-package intero
    :after haskell-mode
    :hook
    (haskell-mode . intero-mode))
#+END_SRC
** C++

The setup here depends on a few items:

1. We use [[https://clang.llvm.org/][Clang]] for our tooling infrastructure
2.  We use ~clang-format~, with [[https://github.com/purcell/reformatter.el][reformatter.el]]

*** cc-mode
#+begin_src emacs-lisp 
  (use-package cc-mode
    :ensure nil
    :mode
    ("\\.c\\'" . c-mode)
    ("\\.cpp\\'" . c++-mode)
    ("\\.h\\'" . c++-mode)
    ("\\.hpp\\'" . c++-mode))
#+end_src
*** C++ compile function
#+begin_src emacs-lisp 
  (add-hook 'c++-mode-hook
            (lambda ()
              (unless (file-exists-p "Makefile")
                (set (make-local-variable 'compile-command)
                     (let ((file (file-name-nondirectory buffer-file-name)))
                       (format "g++ -Wall -s -pedantic-errors %s -o %s --std=c++14"
                               file
                               (file-name-sans-extension file)))))))
#+end_src

*** Clang-format

~clang-format~ ships with the clang-family of tools. Here we use
the reformatter macro to integrate ~clang-format~.

#+begin_src emacs-lisp 
  (use-package reformatter
    :load-path "./elisp/reformatter.el")

  (defvar clang-format-command
    "clang-format"
    "name of executable to format c/c++ files.")

  (use-package clang-format
    :ensure f
    :no-require t  
    :after reformatter
    :config
    (reformatter-define clang-format
      :program clang-format-command)
    (add-hook 'c++-mode-hook 'clang-format-on-save-mode))
#+end_src

*** ccls
[[https://github.com/cquery-project/cquery][cquery]] is a highly-scalable, low-latency language server for
C/C++/Objective-C. ccls is an upgraded fork of cquery.

#+begin_src emacs-lisp 
  (use-package ccls
    :after lsp-mode
    :custom
    (ccls-executable "ccls"))
#+end_src

** Fish
   #+begin_src emacs-lisp 
     (use-package fish-mode
       :mode ("\\.fish\\'" . fish-mode))
   #+end_src
** Rust
   #+begin_src emacs-lisp 
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
   #+end_src
** Python
*** Python Path
#+BEGIN_SRC emacs-lisp 
  (eval-after-load "python-mode"
    (lambda ()
      (setq python-remove-cwd-from-path t)))
#+END_SRC
*** isort
#+BEGIN_SRC emacs-lisp 
  (use-package py-isort
    :commands
    (py-isort-buffer py-isort-region))
#+END_SRC
*** yapfify
#+BEGIN_SRC emacs-lisp 
  (use-package yapfify
    :commands
    (yapfify-buffer))
#+END_SRC
*** pytest
#+BEGIN_SRC emacs-lisp 
  (use-package pytest
    :bind (:map python-mode-map
                ("C-c a" . pytest-all)
                ("C-c m" . pytest-module)
                ("C-c ." . pytest-one)
                ("C-c d" . pytest-directory)
                ("C-c p a" . pytest-pdb-all)
                ("C-c p m" . pytest-pdb-module)
                ("C-c p ." . pytest-pdb-one)))
#+END_SRC
*** Highlight Indent Guides
#+BEGIN_SRC emacs-lisp 
  (use-package highlight-indent-guides
    :defer 10
    :hook
    (python-mode . highlight-indent-guides-mode)
    :custom
    (highlight-indent-guides-method 'character))
#+END_SRC
*** Isend-mode
#+BEGIN_SRC emacs-lisp 
  (use-package isend-mode
    :bind
    (:map isend-mode-map
          ("C-M-e" . isend-send-defun))
    :hook
    (isend-mode. isend-default-python-setup))
#+END_SRC
*** Pyment
#+BEGIN_SRC emacs-lisp 
  (use-package buftra
    :load-path "./elisp")

  (use-package py-pyment
    :load-path "./elisp"
    :hook (python-mode . py-pyment-mode)
    :custom
    (py-pyment-options '("--output" "google")))
#+END_SRC
** HTML
*** web-mode
    #+begin_src emacs-lisp 
      (use-package web-mode
        :mode (("\\.html\\'" . web-mode)
               ("\\.html\\.erb\\'" . web-mode)
               ("\\.mustache\\'" . web-mode)
               ("\\.jinja\\'" . web-mode)
               ("\\.njk\\'" . web-mode)
               ("\\.php\\'" . web-mode)
               ("\\.js[x]?\\'" . web-mode))
        :custom
        (web-mode-enable-css-colorization t)
        (web-mode-content-types-alist
         '(("jsx" . "\\.js[x]?\\'")))
        :config
        (setq-default css-indent-offset 2
                      web-mode-markup-indent-offset 2
                      web-mode-css-indent-offset 2
                      web-mode-code-indent-offset 2
                      web-mode-attr-indent-offset 2))
    #+end_src
*** Emmet-mode
#+begin_src emacs-lisp 
  (use-package emmet-mode
    :diminish emmet-mode
    :hook
    (web-mode . emmet-mode)
    (vue-mode . emmet-mode))
#+end_src
** CSS
*** Rainbow-mode
    #+begin_src emacs-lisp 
      (use-package rainbow-mode
        :diminish rainbow-mode
        :hook
        (css-mode . rainbow-mode)
        (scss-mode . rainbow-mode))
    #+end_src
*** SCSS-mode
    #+begin_src emacs-lisp 
      (use-package scss-mode
        :mode "\\.scss\\'" 
        :custom
        (scss-compile-at-save nil))
    #+end_src
** Javascript
*** JS2-mode
#+begin_src emacs-lisp 
  (use-package js2-mode
    :hook
    (web-mode-hook . js2-minor-mode)
    :config
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint)))
    :custom
    (js-switch-indent-offset 2))
#+end_src
*** Indium
#+BEGIN_SRC emacs-lisp 
  (use-package indium
    :after js2-mode
    :bind (:map js2-mode-map
                ("C-c C-l" . indium-eval-buffer))
    :hook
    ((js2-mode . indium-interaction-mode)))
#+END_SRC
*** js-doc
#+BEGIN_SRC emacs-lisp 
  (use-package js-doc
    :after js2-mode
    :bind (:map js2-mode-map
                ("C-c i" . js-doc-insert-function-doc)
                ("@" . js-doc-insert-tag))
    :custom
    (js-doc-mail-address "jethrokuan95@gmail.com")
    (js-doc-author (format "Jethro Kuan <%s>" js-doc-mail-address))
    (js-doc-url "http://www.jethrokuan.com/")
    (js-doc-license "MIT"))
#+END_SRC

*** prettier
#+BEGIN_SRC emacs-lisp 
  (use-package prettier-js
    :hook
    (js2-minor-mode . prettier-js-mode))
#+END_SRC
** Java
*** Java LSP Setup
#+BEGIN_SRC emacs-lisp 
  (use-package lsp-java
    :after lsp-mode
    :hook
    (java-mode . lsp-java-enable))
#+END_SRC
** Typescript
*** typescript-mode
#+BEGIN_SRC emacs-lisp 
  (use-package typescript-mode
    :mode "\\.ts\\'")
#+END_SRC

*** Tide
#+BEGIN_SRC emacs-lisp 
  (use-package tide
    :after typescript-mode
    :hook
    (before-save . tide-format-before-save)
    (typescript-mode . (lambda ()
                         (tide-setup)
                         (flycheck-mode +1)
                         (tide-hl-identifier-mode +1)
                         (company-mode +1))))
#+END_SRC
** JSON
   #+begin_src emacs-lisp 
     (use-package json-mode
       :mode "\\.json\\'"
       :hook
       (json-mode . (lambda ()
                      (make-local-variable 'js-indent-level)
                      (setq js-indent-level 2))))
   #+end_src
** Markdown
   #+begin_src emacs-lisp 
     (use-package markdown-mode
       :mode ("\\.md\\'" . markdown-mode)
       :commands (markdown-mode gfm-mode)
       :custom
       (markdown-fontify-code-blocks-natively t)
       (markdown-command "multimarkdown --snippet --smart --notes")
       (markdown-enable-wiki-links t)
       (markdown-indent-on-enter 'indent-and-new-item)
       (markdown-asymmetric-header t)
       (markdown-live-preview-delete-export 'delete-on-destroy))
   #+end_src
** AsciiDoc
#+BEGIN_SRC emacs-lisp 
  (use-package adoc-mode
    :mode ("\\.adoc\\'" . adoc-mode))
#+END_SRC
** Latex
*** AucTeX
    #+BEGIN_SRC emacs-lisp 
      (use-package auctex
        :defer t
        :mode ("\\.tex\\'" . latex-mode)
        :custom
        (TeX-auto-save t)
        (TeX-parse-self t)
        (TeX-syntactic-comment t)
        ;; Synctex Support
        (TeX-source-correlate-start-server nil)
        ;; Don't insert line-break at inline math
        (LaTeX-fill-break-at-separators nil)
        (TeX-view-program-list '(("zathura" "zathura --page=%(outpage) %o")))
        (TeX-view-program-selection '((output-pdf "zathura")))
        :config
        (setq-default TeX-engine 'luatex)
        (add-hook 'LaTeX-mode-hook
                  (lambda ()
                    (company-mode)
                    (setq TeX-PDF-mode t)
                    (setq TeX-source-correlate-method 'synctex)
                    (setq TeX-source-correlate-start-server t)))
        (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
        (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
        (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode))
    #+END_SRC
*** Autocomplete support
    #+BEGIN_SRC emacs-lisp 
      (use-package company-auctex
        :after auctex company-mode)
    #+END_SRC
** Yaml
#+BEGIN_SRC emacs-lisp 
  (use-package yaml-mode
    :mode ("\\.yaml\\'" . yaml-mode))
#+END_SRC
** Scala
#+BEGIN_SRC emacs-lisp 
  (use-package ensime
    :commands ensime ensime-mode)
#+END_SRC
** R
#+BEGIN_SRC emacs-lisp 
  (use-package ess)
#+END_SRC
* Org-Mode
** Setup
  I use =org-plus-contrib=, which contains several contrib plugins,
  including =org-drill= and some =org-babel= language support.

  To install =org-plus-contrib=, add the package archive to
  Emacs.

  #+BEGIN_SRC emacs-lisp :tangle no
  (when (>= emacs-major-version 24)
    (require 'package)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
    (package-initialize))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp 
    (use-package org
      :ensure org-plus-contrib
      :mode ("\\.org\\'" . org-mode)
      :bind
      (("C-c l" . org-store-link)
       ("C-c a" . org-agenda)
       ("C-c b" . org-iswitchb)
       ("C-c c" . org-capture))
      :bind
      (:map org-mode-map
            ("M-n" . outline-next-visible-heading)
            ("M-p" . outline-previous-visible-heading))
      :custom
      (org-src-window-setup 'current-window)
      (org-return-follows-link t)
      (org-agenda-diary-file "~/.org/diary.org")
      (org-babel-load-languages
       '((emacs-lisp . t)
         (python . t)))
      (org-use-speed-commands t)
      (org-catch-invisible-edits 'show)
      :custom-face
      (variable-pitch ((t (:family "iA Writer Duospace" :height 0.9))))
      (org-document-title ((t (:weight bold :height 1.5))))
      (org-done ((t (:strike-through t :weight bold))))
      (org-headline-done ((t (:strike-through t))))
      (org-level-1 ((t (:height 1.3 :weight bold))))
      (org-level-2 ((t (:height 1.2 :weight bold))))
      (org-level-3 ((t (:height 1.1 :weight bold))))
      (org-image-actual-width (/ (display-pixel-width) 2))
      :custom
      (org-structure-template-alist '(("a" . "export ascii")
                                      ("c" . "center")
                                      ("C" . "comment")
                                      ("e" . "example")
                                      ("E" . "export")
                                      ("h" . "export html")
                                      ("l" . "export latex")
                                      ("q" . "quote")
                                      ("s" . "src")
                                      ("v" . "verse")
                                      ("el" . "src emacs-lisp")
                                      ("d" . "definition")
                                      ("t" . "theorem")))
      :config
      (require 'org-habit)
      (require 'org-tempo))
  #+END_SRC

*** Variable Pitch Mode
We use a font that's easier on the eyes for long blocks of text. (ET Bembo)

 #+BEGIN_SRC emacs-lisp 
   (add-hook 'org-mode-hook
             '(lambda ()
                (setq line-spacing 0.2) ;; Add more line padding for readability
                (variable-pitch-mode 1) ;; All fonts with variable pitch.
                (mapc
                 (lambda (face) ;; Other fonts with fixed-pitch.
                   (set-face-attribute face nil :inherit 'fixed-pitch))
                 (list 'org-code
                       'org-link
                       'org-block
                       'org-table
                       'org-verbatim
                       'org-block-begin-line
                       'org-block-end-line
                       'org-meta-line
                       'org-document-info-keyword))))
 #+END_SRC

Other org-mode ricing configuration:

#+BEGIN_SRC emacs-lisp 
  (setq org-startup-indented t
        org-hide-emphasis-markers t
        org-pretty-entities nil)
#+END_SRC

*** Helper Functions
#+BEGIN_SRC emacs-lisp 
  (defun org-archive-done-tasks ()
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+END_SRC
*** Org Gcal
#+BEGIN_SRC emacs-lisp 
  (use-package password-store
    :defer 10
    :init
    (require 'auth-source-pass)
    :load-path "./elisp"
    :custom
    (auth-source-backend '(password-store)))

  (use-package org-gcal
    :after (auth-source-pass password-store)
    :custom
    (org-gcal-client-id "1025518578318-g5llmkeftf20ct2s7j0b4pmu7tr6am1r.apps.googleusercontent.com")
    (org-gcal-client-secret `,(auth-source-pass-get 'secret "gmail/org-gcal"))
    (jethro/org-gcal-directory "~/.org/gtd/calendars/")
    :config
    (defun jethro/get-gcal-file-location (loc)
      (concat (file-name-as-directory jethro/org-gcal-directory) loc))
    (setq org-gcal-file-alist `(("jethrokuan95@gmail.com" . ,(jethro/get-gcal-file-location "personal.org"))
                                ("62ad47vpojb2uqb53hpnqsuv5o@group.calendar.google.com" . ,(jethro/get-gcal-file-location "school.org"))
                                ("15rmvcq9uehc0e4ccorj5hbm8o@group.calendar.google.com" . ,(jethro/get-gcal-file-location "6101.org")))))
#+END_SRC
**** Run on Timer
Run org-gcal-fetch every hour to update the calendars.
#+BEGIN_SRC emacs-lisp 
  (run-at-time (* 60 60) nil
               (lambda ()
                 (let ((inhibit-message t))
                   (org-gcal-refresh-token)
                   (org-gcal-fetch))))
#+END_SRC

** Org Mode for GTD
This subsection aims to extensively document my implementation of
Getting Things Done, a methodology by David Allen. This will always be
a work-in-progress, and is *fully representative* of the GTD setup I
am currently using.

This document is written primarily for my own reference.
However, it is also written with readers who are looking for
inspiration when implementing GTD in org-mode.

*** Why my own implementation of GTD?
 There is no shortage of existing GTD implementations, in org-mode.
 Perhaps the best reference document out there is by Bernt Hansen,
 published [[http://doc.norang.ca/org-mode.html][here]]. However, there are some slight deviations from the
 GTD that David Allen proposes, and some conveniences he takes making
 the GTD system he implements weaker, that can perhaps be solved by
 writing some Elisp. This is a major adaptation of his setup, but with
 additional customizations that make it more similar to the ideal
 system that David Allen speaks about.

Other references include:

- [[http://howardism.org/Technical/Emacs/getting-boxes-done.html][Getting Boxes Done]]

*** Organizing Your Life Into Org-mode Files
 Bernt Hansen uses separate files as logical groups, such as a
 separation between work and life. This may suit your purpose, but this
 makes it a lot harder to write general Elisp code for. Once a new
 logical group appears, the code that generates the weekly review would
 have to change as well, for example.

 Instead, I use David Allen's physical categories as different files,
 and use org-mode tags to separate the different context. That is, I
 have the files:

 | file (.org) | Purpose                                                                                                                   |
 |-------------+---------------------------------------------------------------------------------------------------------------------------|
 | inbox       | Includes everything on your mind: tasks, ideas etc.                                                                       |
 | someday     | Includes things that will be done later on (with no specific deadline), to be reviewed often                              |
 | reference   | I don't actually have this file; I use [[http://jblevins.org/projects/deft/%5Ddeft-mode][deft-mode]] as my braindump                                                          |
 | next        | This contains one-off tasks that don't belong to projects.                                                                |
 | projects    | This contains the list of projects, and their corresponding todo items                                                    |

 #+BEGIN_SRC emacs-lisp 
   (require 'find-lisp)
   (setq jethro/org-agenda-directory "~/.org/gtd/")
   (setq org-agenda-files
         (find-lisp-find-files jethro/org-agenda-directory "\.org$"))
 #+END_SRC

*** Stage 1: Collecting
 Collecting needs to be convenient. This is achieved easily be using
 =org-capture=. The capture template is kept simple, to minimize
 friction in capturing new items as they pop up.

 #+BEGIN_SRC emacs-lisp 
   (setq org-capture-templates
         `(("i" "inbox" entry (file ,(concat jethro/org-agenda-directory "inbox.org"))
            "* TODO %?")
           ("e" "email" entry (file+headline ,(concat jethro/org-agenda-directory "emails.org") "Emails")
            "* TODO [#A] Reply: %a :@home:@school:" :immediate-finish t)
           ("l" "link" entry (file ,(concat jethro/org-agenda-directory "inbox.org"))
            "* TODO %(org-cliplink-capture)" :immediate-finish t)
           ("z" "elfeed-link" entry (file ,(concat jethro/org-agenda-directory "inbox.org"))
            "* TODO %a\n" :immediate-finish t)
           ("w" "Weekly Review" entry (file+olp+datetree ,(concat jethro/org-agenda-directory "reviews.org"))
            (file ,(concat jethro/org-agenda-directory "templates/weekly_review.org")))))
 #+END_SRC
*** Stage 2: Processing
 During predetermined times of each day, process the inbox, each item
 in =inbox= sorted into their respective folders.

 =org-agenda= provides a brilliant interface for processing the inbox.
 At the end of the "processing" stage, =inbox.org= should be empty.

 A few factors are key:

 1. *Which file*: Is this to be done someday when there's time, or is
    this a project (old or new), or is this a simple action?
 2. *Adding of context*: Is this school-related, or work-related? Do I
    have to be at a specific location to perform this task?

 Each item in =inbox.org= would be placed in either a non-actionable
 file, or an actionable file (=projects=, or =next=) with a physical
 actionable.

 David Allen recommends processing inbox items top-down or bottom-up,
 one item at a time. However, I like to have an overview of my inbox,
 so I can estimate the number of items left to process.

 This process is therefore contigent on several factors:
 1. *There aren't too many items in the inbox at the same time.* This
    can prove to be too distracting. Fortunately, I've yet to
    experience this.
 2. *Processing of inbox is more regular.* Keeping inbox zero at all
    times should be a goal, but not a priority.

**** Org Agenda Reading view
This view is where I see items I have queued up in my reading list.

#+BEGIN_SRC emacs-lisp 
  (setq jethro/org-agenda-reading-view
        `("r" "Reading" todo ""
          ((org-agenda-files '(,(concat jethro/org-agenda-directory "reading.org"))))))

  (add-to-list 'org-agenda-custom-commands `,jethro/org-agenda-reading-view)
#+END_SRC

**** Org TODO Keywords
 | keyword   | meaning                                                                      |
 |-----------+------------------------------------------------------------------------------|
 | TODO      | An item that has yet to be processed, or cannot be attempted at this moment. |
 | NEXT      | An action that can be completed at this very moment, in the correct context  |
 | DONE      | An item that is completed, and ready to be archived                          |
 | WAITING   | An item that awaits input from an external party                             |
 | HOLD      | An item that is delayed due to circumstance                                  |
 | CANCELLED | An item that was once considered, but no longer to be attempted              |

 =WAITING=, =HOLD=, and =CANCELLED= are all keywords that require
 supplementary information. For example, who am I waiting for? Or why
 is this item on hold? As such, it is convenient to trigger a note when
 an item transitions to these states. Note that the triggers only
 happen with "slow" state transitions, i.e. =C-c C-t=.

 #+BEGIN_SRC emacs-lisp 
   (setq org-todo-keywords
         '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
           (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))

   (setq org-log-done 'time)
   (setq org-log-into-drawer t)
   (setq org-log-state-notes-insert-after-drawers nil)
 #+END_SRC
**** The Process
***** Step 1: Clarifying
****** Tags
 #+BEGIN_SRC emacs-lisp 
   (setq org-tag-alist (quote (("@errand" . ?e)
                               ("@office" . ?o)
                               ("@home" . ?h)
                               ("@school" . ?s)
                               (:newline)
                               ("WAITING" . ?w)
                               ("HOLD" . ?H)
                               ("CANCELLED" . ?c))))

   (setq org-fast-tag-selection-single-key nil)

 #+END_SRC
***** Step 2: Organizing
 This step involves refiling the item in the appropriate location. We
 set =org-refile-allow-creating-parent-nodes= to ='confirm=, because this
 allows us to create new projects if there are no matches.

 When capturing new projects, it helps to pen down a few things about
 the project:

 1. Project Purpose/Principles
 2. Outcome Vision

 This is currently done using =org-add-note=, but when my elisp-fu gets
 stronger, I'd create a dedicated buffer with a template each time a
 project is created.

 #+BEGIN_SRC emacs-lisp 
   ;; https://github.com/syl20bnr/spacemacs/issues/3094
   (setq org-refile-use-outline-path 'file
         org-outline-path-complete-in-steps nil)
   (setq org-refile-allow-creating-parent-nodes 'confirm)
   (setq org-refile-targets '(("next.org" :level . 0)
                              ("someday.org" :level . 0)
                              ("reading.org" :level . 1)
                              ("projects.org" :maxlevel . 1)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp 
   (defvar jethro/org-agenda-bulk-process-key ?f
     "Default key for bulk processing inbox items.")

   (defun jethro/org-process-inbox ()
     "Called in org-agenda-mode, processes all inbox items."
     (interactive)
     (org-agenda-bulk-mark-regexp "inbox:")
     (jethro/bulk-process-entries))

   (defun jethro/org-agenda-process-inbox-item ()
     "Process a single item in the org-agenda."
     (org-with-wide-buffer
      (org-agenda-set-tags)
      (org-agenda-priority)
      (org-agenda-set-effort)
      (org-agenda-refile nil nil t)))

   (defun jethro/bulk-process-entries ()
     (if (not (null org-agenda-bulk-marked-entries))
         (let ((entries (reverse org-agenda-bulk-marked-entries))
               (processed 0)
               (skipped 0))
           (dolist (e entries)
             (let ((pos (text-property-any (point-min) (point-max) 'org-hd-marker e)))
               (if (not pos)
                   (progn (message "Skipping removed entry at %s" e)
                          (cl-incf skipped))
                 (goto-char pos)
                 (let (org-loop-over-headlines-in-active-region) (funcall 'jethro/org-agenda-process-inbox-item))
                 ;; `post-command-hook' is not run yet.  We make sure any
                 ;; pending log note is processed.
                 (when (or (memq 'org-add-log-note (default-value 'post-command-hook))
                           (memq 'org-add-log-note post-command-hook))
                   (org-add-log-note))
                 (cl-incf processed))))
           (org-agenda-redo)
           (unless org-agenda-persistent-marks (org-agenda-bulk-unmark-all))
           (message "Acted on %d entries%s%s"
                    processed
                    (if (= skipped 0)
                        ""
                      (format ", skipped %d (disappeared before their turn)"
                              skipped))
                    (if (not org-agenda-persistent-marks) "" " (kept marked)")))
       ))



   (defun jethro/org-inbox-capture ()
     (interactive)
     "Capture a task in agenda mode."
     (org-capture nil "i"))

   (setq org-agenda-bulk-custom-functions `((,jethro/org-agenda-bulk-process-key jethro/org-agenda-process-inbox-item)))

   (define-key org-agenda-mode-map "i" 'org-agenda-clock-in)
   (define-key org-agenda-mode-map "r" 'jethro/org-process-inbox)
   (define-key org-agenda-mode-map "R" 'org-agenda-refile)
   (define-key org-agenda-mode-map "c" 'jethro/org-inbox-capture)
 #+END_SRC
**** Clocking in
#+BEGIN_SRC emacs-lisp 
  (defun jethro/set-todo-state-next ()
    "Visit each parent task and change NEXT states to TODO"
    (org-todo "NEXT"))

  (add-hook 'org-clock-in-hook 'jethro/set-todo-state-next 'append)
#+END_SRC

#+begin_src emacs-lisp 
  (use-package org-clock-convenience
    :bind (:map org-agenda-mode-map
                ("<S-up>" . org-clock-convenience-timestamp-up)
                ("<S-down>" . org-clock-convenience-timestamp-down)
                ("o" . org-clock-convenience-fill-gap)
                ("e" . org-clock-convenience-fill-gap-both)))
#+end_src
*** Stage 3: Reviewing
**** Custom agenda Commands
 #+BEGIN_SRC emacs-lisp 
   (setq org-agenda-block-separator nil)
   (setq org-agenda-start-with-log-mode t)

   (setq jethro/org-agenda-todo-view
         `(" " "Agenda"
           ((agenda ""
                    ((org-agenda-span 'day)
                     (org-deadline-warning-days 365)))
            (todo "TODO"
                  ((org-agenda-overriding-header "To Refile")
                   (org-agenda-files '(,(concat jethro/org-agenda-directory "inbox.org")))))
            (todo "TODO"
                  ((org-agenda-overriding-header "Emails")
                   (org-agenda-files '(,(concat jethro/org-agenda-directory "emails.org")))))
            (todo "NEXT"
                  ((org-agenda-overriding-header "In Progress")
                   (org-agenda-files '(,(concat jethro/org-agenda-directory "someday.org")
                                       ,(concat jethro/org-agenda-directory "projects.org")
                                       ,(concat jethro/org-agenda-directory "next.org")))
                   ;; (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "Projects")
                   (org-agenda-files '(,(concat jethro/org-agenda-directory "projects.org")))
                   ;; (org-agenda-skip-function #'jethro/org-agenda-skip-all-siblings-but-first)
                   ))
            (todo "TODO"
                  ((org-agenda-overriding-header "One-off Tasks")
                   (org-agenda-files '(,(concat jethro/org-agenda-directory "next.org")))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            nil)))

   (add-to-list 'org-agenda-custom-commands `,jethro/org-agenda-todo-view)

   (defun jethro/org-agenda-skip-all-siblings-but-first ()
     "Skip all but the first non-done entry."
     (let (should-skip-entry)
       (unless (or (org-current-is-todo)
                   (not (org-get-scheduled-time (point))))
         (setq should-skip-entry t))
       (save-excursion
         (while (and (not should-skip-entry) (org-goto-sibling t))
           (when (org-current-is-todo)
             (setq should-skip-entry t))))
       (when should-skip-entry
         (or (outline-next-heading)
             (goto-char (point-max))))))

   (defun org-current-is-todo ()
     (string= "TODO" (org-get-todo-state)))

   (defun jethro/switch-to-agenda ()
     (interactive)
     (org-agenda nil " ")
     (delete-other-windows))

   (bind-key "<f1>" 'jethro/switch-to-agenda)
 #+END_SRC
**** Column View
#+BEGIN_SRC emacs-lisp 
  (setq org-columns-default-format "%40ITEM(Task) %Effort(EE){:} %CLOCKSUM(Time Spent) %SCHEDULED(Scheduled) %DEADLINE(Deadline)")
#+END_SRC
*** Stage 4: Doing
**** Org-pomodoro
#+BEGIN_SRC emacs-lisp 
  (use-package org-pomodoro
    :after org
    :bind
    (:map org-agenda-mode-map
          (("I" . org-pomodoro)))
    :custom
    (org-pomodoro-format "%s"))
#+END_SRC
** Org Mode for Note taking
*** org-cliplink
 A simple command that takes a URL from the clipboard and inserts an
 org-mode link with a title of a page found by the URL into the
 current buffer.

#+BEGIN_SRC emacs-lisp 
  (use-package org-cliplink
    :bind
    ("C-c C" . 'jethro/org-capture-link)
    :config
    (defun jethro/org-capture-link ()
      "Captures a link, and stores it in inbox."
      (interactive)
      (org-capture nil "l")))
#+END_SRC
*** Deft
#+BEGIN_SRC emacs-lisp 
  (use-package deft
    :after org
    :bind
    (("C-c n" . deft))
    :custom
    (deft-default-extension "org")
    (deft-directory "~/.org/braindump/org")
    (deft-use-filename-as-title t))
#+END_SRC
*** Exporting Deft Notes
#+BEGIN_SRC emacs-lisp 
  (defun jethro/org-export-deft-file (file)
    (interactive)
    (org-html-export-to-html t t))
#+END_SRC
*** Org Download
This extension facilitates moving images from point A to point B. Use
this to capture screenshots into deft.
 #+BEGIN_SRC emacs-lisp 
   (use-package org-download
     :after org
     :bind
     (:map org-mode-map
           (("s-Y" . org-download-screenshot)
            ("s-y" . org-download-yank)))
     :config
     (if (memq window-system '(mac ns))
         (setq org-download-screenshot-method "screencapture -i %s")
       (setq org-download-screenshot-method "maim -s %s"))
     (defun my-org-download-method (link)
       "This is a helper function for org-download.
   It creates a folder in the root directory (~/.org/img/) named after the
   org filename (sans extension) and puts all images from that file in there.
   Inspired by https://github.com/daviderestivo/emacs-config/blob/6086a7013020e19c0bc532770e9533b4fc549438/init.el#L701"
       (let ((filename
              (file-name-nondirectory
               (car (url-path-and-query
                     (url-generic-parse-url link)))))
             ;; Create folder name with current buffer name, and place in root dir
             (dirname (concat "./images/"
                              (replace-regexp-in-string " " "_" (downcase (file-name-base buffer-file-name))))))

         ;; Add timestamp to filename
         (setq filename-with-timestamp (format "%s%s.%s"
                                               (file-name-sans-extension filename)
                                               (format-time-string org-download-timestamp)
                                               (file-name-extension filename)))
         ;; Create folder if necessary
         (unless (file-exists-p dirname)
           (make-directory dirname))
         (expand-file-name filename-with-timestamp dirname)))
     (setq org-download-method 'my-org-download-method))
 #+END_SRC
** Org Mode for Journalling
#+BEGIN_SRC emacs-lisp 
  (use-package org-journal
    :custom
    (org-journal-dir "~/.org/journal/"))
#+END_SRC
** Org Mode for Blogging
I use ox-hugo.

#+BEGIN_SRC emacs-lisp 
  (use-package ox-hugo
    :after org
    :custom
    (org-hugo-auto-set-lastmod t))

  (use-package ox-hugo-auto-export
    :ensure f
    :after ox-hugo)
#+END_SRC
** Exporting PDFs
I use export to LaTeX through ox-latex, using xelatex for a nicer export template.
#+begin_src emacs-lisp 
  (use-package ox-latex
    :after org
    :ensure f
    :config
    :custom
    (org-latex-pdf-process
     (list "latexmk -shell-escape -bibtex -f -pdf %f"
           "latexmk -shell-escape -bibtex -f -pdf %f"))
    (org-latex-default-table-environment "tabular")
    (org-latex-tables-booktabs t)
    (org-latex-listings 'minted)
    (org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
    (org-latex-classes
     '(("article"
        "\\documentclass{article}
  \\usepackage[margin=1in]{geometry}
  \\usepackage{amsmath,amsthm,amssymb}
  \\newtheorem{definition}{Definition}
  \\newtheorem{theorem}{Theorem}

  \\usepackage{booktabs}
  \\usepackage{hyperref}
  \\usepackage{minted}
  \\usepackage{tabularx}
  \\usepackage{parskip}
  \\linespread{1.1}"
        ("\\section{%s}" . "\\section*{%s}")
        ("\\subsection{%s}" . "\\subsection*{%s}")
        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
        ("\\paragraph{%s}" . "\\paragraph*{%s}")
        ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
       ("book"
        "\\documentclass[10pt]{memoir}
                          \\usepackage{charter}
                          \\usepackage[T1]{fontenc}
                          \\usepackage{booktabs}
                          \\usepackage{amsmath}
                          \\usepackage{minted}
                          \\usemintedstyle{borland}
                          \\usepackage{color}
                          \\usepackage{epigraph}
                          \\usepackage{enumitem}
                          \\setlist{nosep}
                          \\setlength\\epigraphwidth{13cm}
                          \\setlength\\epigraphrule{0pt}
                          \\usepackage{fontspec}
                          \\usepackage{graphicx}
                          \\usepackage{hyperref}
                          \\hypersetup {colorlinks = true, allcolors = red}
                          \\title{}
                          [NO-DEFAULT-PACKAGES]
                          [NO-PACKAGES]"
        ("\\chapter{%s}" . "\\chapter*{%s}")
        ("\\section{%s}" . "\\section*{%s}")
        ("\\subsection{%s}" . "\\subsection*{%s}")
        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
        ("\\paragraph{%s}" . "\\paragraph*{%s}")
        ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
       ("latex-notes"
        "\\documentclass[8pt]{article}
    \\usepackage[margin={0.1in,0.1in}, a4paper,landscape]{geometry}
    \\usepackage{hyperref}
    \\usepackage{amsmath}
    \\usepackage{multicol}
    \\usepackage{booktabs}
    \\usepackage{enumitem}
    \\usepackage[compact]{titlesec}
    \\renewcommand\\maketitle{}
    \\titlespacing{\\section}{0pt}{*2}{*0}
    \\titlespacing{\\subsection}{0pt}{*2}{*0}
    \\titlespacing{\\subsubsection}{0pt}{*2}{*0}
    \\titleformat*{\\section}{\\large\\bfseries}
    \\titleformat*{\\subsection}{\\normalsize\\bfseries}
    \\titleformat*{\\subsubsection}{\\normalsize\\bfseries}
    \\setlist[itemize]{leftmargin=*}
    \\setlist[enumerate]{leftmargin=*}
    \\setlength\\columnsep{5pt}
    \\setlength{\\columnseprule}{1pt}
    \\setlength{\\parindent}{0cm}
    \\usepackage{setspace}
    \\singlespacing
    \\setlist{nosep}
    \\usepackage{minted}
    \\usemintedstyle{bw}
    \\usemintedstyle[java]{bw}
    \\setminted[]{frame=none,fontsize=\\footnotesize,linenos=false}
    "
        ("\\section{%s}" . "\\section*{%s}")
        ("\\subsection{%s}" . "\\subsection*{%s}")
        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
        ("\\paragraph{%s}" . "\\paragraph*{%s}")
        ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
    :config
    (defvar-local jethro/org-multicol-latex-column-count
      3
      "Column count for multicolumn export.")

    (defun jethro/org-multicol-to-pdf (async subtreep visible-only body-only)
      (let ((contents (buffer-string))
            (buffer-name (file-name-sans-extension buffer-file-name))
            (col-count jethro/org-multicol-latex-column-count))
        (with-temp-buffer
          (insert "#+LATEX_CLASS: latex-notes\n")
          (insert contents)
          (goto-char (point-min))
          (org-next-visible-heading 1)
          (insert
           (format "#+BEGIN_EXPORT latex\n\\begin{multicols*}{%s}\n#+END_EXPORT\n" col-count))
          (goto-char (point-max))
          (insert "#+BEGIN_EXPORT latex\n\\end{multicols*}\n#+END_EXPORT")
          (org-export-to-file 'latex (format "%s.tex" buffer-name)
            async subtreep visible-only body-only nil (lambda (file) (org-latex-compile file))))))

    (org-export-define-derived-backend 'latex-notes 'latex
      :menu-entry
      '(?L "Export to LaTeX notes"
           ((?p "Export to PDF" jethro/org-multicol-to-pdf)))))
#+end_src
* Project Management
** Version Control
*** vc
#+BEGIN_SRC emacs-lisp 
  (use-package vc
    :bind (("C-x v =" . jethro/vc-diff)
           ("C-x v H" . vc-region-history)) ; New command in emacs 25.x
    :config
    (defun jethro/vc-diff (no-whitespace)
      "Call `vc-diff' as usual if buffer is not modified.
  If the buffer is modified (yet to be saved), call `diff-buffer-with-file'.
  If NO-WHITESPACE is non-nil, ignore all white space when doing diff."
      (interactive "P")
      (let* ((no-ws-switch '("-w"))
             (vc-git-diff-switches (if no-whitespace
                                       no-ws-switch
                                     vc-git-diff-switches))
             (vc-diff-switches (if no-whitespace
                                   no-ws-switch
                                 vc-diff-switches))
             (diff-switches (if no-whitespace
                                no-ws-switch
                              diff-switches))
             ;; Set `current-prefix-arg' to nil so that the HISTORIC arg
             ;; of `vc-diff' stays nil.
             current-prefix-arg)
        (if (buffer-modified-p)
            (diff-buffer-with-file (current-buffer))
          (call-interactively #'vc-diff)))))
#+END_SRC
*** Smerge-mode
Useful when handling git merge conflicts.

#+BEGIN_SRC emacs-lisp 
  (use-package smerge-mode
    :bind (("C-c h s" . jethro/hydra-smerge/body))
    :init
    (defun jethro/enable-smerge-maybe ()
      "Auto-enable `smerge-mode' when merge conflict is detected."
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^<<<<<<< " nil :noerror)
          (smerge-mode 1))))
    (add-hook 'find-file-hook #'jethro/enable-smerge-maybe :append)
    :config
    (defhydra jethro/hydra-smerge (:color pink
                                          :hint nil
                                          :pre (smerge-mode 1)
                                          ;; Disable `smerge-mode' when quitting hydra if
                                          ;; no merge conflicts remain.
                                          :post (smerge-auto-leave))
      "
     ^Move^       ^Keep^               ^Diff^                 ^Other^
     ^^-----------^^-------------------^^---------------------^^-------
     _n_ext       _b_ase               _<_: upper/base        _C_ombine
     _p_rev       _u_pper              _=_: upper/lower       _r_esolve
     ^^           _l_ower              _>_: base/lower        _k_ill current
     ^^           _a_ll                _R_efine
     ^^           _RET_: current       _E_diff
     "
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("k" smerge-kill-current)
      ("q" nil "cancel" :color blue)))
#+end_src
*** Magit
 #+begin_src emacs-lisp
   (use-package magit
     :bind (("s-g" . magit-status)
            ("C-c g" . magit-status)
            ("s-G" . magit-blame-addition)
            ("C-c G" . magit-blame-addition))
     :hook
     (magit-mode . hl-line-mode)
     :custom
     (magit-auto-revert-mode nil)
     (magit-log-arguments '("-n100" "--graph" "--decorate"))
     :config
     (magit-define-popup-switch 'magit-log-popup
       ?m "Omit merge commits" "--no-merges"))
 #+END_SRC
*** Git-link
Git-link creates URLs for files and commits in Github/Bitbucket/Gitlab repositories.
#+BEGIN_SRC emacs-lisp
  (use-package git-link
    :commands
    (git-link git-link-commit git-link-homepage)
    :custom
    (git-link-use-commit t))
#+END_SRC
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :custom
    (projectile-use-git-grep t)
    (projectile-create-missing-test-files t)
    (projectile-completion-system 'ivy)
    (projectile-switch-project-action  #'projectile-commander)
    :config
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
    (projectile-mode +1)
    (def-projectile-commander-method ?S
      "Run a search in the project"
      (counsel-projectile-rg))
    (def-projectile-commander-method ?s
      "Open a *eshell* buffer for the project."
      (projectile-run-eshell))
    (def-projectile-commander-method ?d
      "Open project root in dired."
      (projectile-dired))
    (def-projectile-commander-method ?g
      "Show magit status."
      (magit-status)))

  (use-package counsel-projectile
    :after ivy projectile
    :bind (("s-f" . counsel-projectile-find-file)
           ("s-b" . counsel-projectile-switch-to-buffer)
           ("C-c s" . counsel-projectile-rg)))
#+end_src
* Miscellaneous
** bury-successful-compilation
Closes compile buffer if there are no errors.
#+begin_src emacs-lisp
  (use-package bury-successful-compilation
    :hook
    (prog-mode . bury-successful-compilation))
#+end_src
** Citations with ox-hugo and org-ref
#+BEGIN_SRC emacs-lisp
  (use-package org-ref
    :after org)

  (use-package ox-hugo-org-ref-overrides
    :after org org-ref ox-hugo
    :load-path "./elisp/ox-hugo-org-ref/")
#+END_SRC
** pdf-tools
#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (pdf-tools-install))
#+end_src
